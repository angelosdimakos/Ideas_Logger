{
  "__init__.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": []
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {}
    },
    "linting": {}
  },
  "ai/__init__.py": {
    "docstrings": {
      "module_doc": {
        "description": "The `ai` module provides AI-powered summarization utilities for text entries using large language models (LLMs).\nCore features include:\n- Generating concise summaries for individual or multiple text entries.\n- Supporting subcategory-specific prompts for context-aware summarization.\n- Configurable model selection and prompt templates, loaded at initialization.\n- Fallback to the Ollama chat API for summarization if the primary LLM fails.\n- Designed for seamless integration into workflows requiring automated, high-quality text summarization.\nThis module enables flexible and robust summarization capabilities for downstream applications such as log analysis, reporting, and intelligent querying.",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": []
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {}
    },
    "linting": {
      "quality": {
        "coverage": {
          "percent": 100.0
        }
      }
    }
  },
  "ai/ai_cli.py": {
    "docstrings": {
      "module_doc": {
        "description": "AI Command Line Interface for Zephyrus Logger\n===============================\nThis module provides a command-line interface for the AI summarization\nfunctionality within the Zephyrus Logger application, allowing users\nto log entries, generate summaries, and search through logs.",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "cli",
          "description": "Command-line interface for the Zephyrus Logger AI functionalities.\nThis function sets up the argument parser and defines the available\nsubcommands for logging entries, summarizing categories, searching\nlogs, and summarizing module docstrings.",
          "args": null,
          "returns": null
        }
      ]
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {
        "cli": {
          "complexity": 7,
          "coverage": 0.0,
          "hits": 0,
          "lines": 33,
          "covered_lines": [],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "mypy": {
          "errors": [
            "scripts/ai/ai_cli.py:14: error: Module \"scripts.ai.module_docstring_summarizer\" has no attribute \"main\"  [attr-defined]",
            "scripts/ai/ai_cli.py:19: error: Function is missing a return type annotation  [no-untyped-def]",
            "scripts/ai/ai_cli.py:81: error: Call to untyped function \"cli\" in typed context  [no-untyped-call]"
          ]
        },
        "black": {
          "needs_formatting": true
        }
      }
    }
  },
  "ai/ai_summarizer.py": {
    "docstrings": {
      "module_doc": {
        "description": "This module provides the AISummarizer class for generating summaries of text entries\nusing a configurable large language model (LLM).\nIt supports both single-entry and bulk summarization, with the ability to use\nsubcategory-specific prompts loaded from configuration. If the primary summarization\nmethod fails, the module falls back to the Ollama chat API to attempt summarization.\nLogging is integrated throughout for monitoring and debugging,\nand configuration is loaded at initialization for flexible model and prompt management.\nTypical use cases include automated summarization of logs, notes, or other textual data\nin workflows requiring concise, context-aware summaries.",
        "args": null,
        "returns": null
      },
      "classes": [
        {
          "name": "AISummarizer",
          "description": "AISummarizer provides methods to generate summaries for single or multiple text entries\nusing a configurable LLM model and subcategory-specific prompts. It supports fallback\nto the Ollama chat API if primary summarization fails and loads configuration settings\nat initialization.",
          "args": null,
          "returns": null
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "description": "Initialize AISummarizer by loading configuration, setting the LLM model,\nand preparing prompts by subcategory.",
          "args": null,
          "returns": null
        },
        {
          "name": "_fallback_summary",
          "description": "Attempt to generate a summary using the Ollama chat API as a fallback when\nprimary summarization fails.",
          "args": "full_prompt (str): The prompt to send to the chat model.",
          "returns": "str: The generated summary or an error message."
        },
        {
          "name": "summarize_entry",
          "description": "Generate a summary for a single text entry using the configured LLM model\nand an optional subcategory-specific prompt.",
          "args": "entry_text (str): The text to summarize.\nsubcategory (Optional[str], optional): The subcategory to use for the prompt.",
          "returns": "str: The generated summary or a fallback message if summarization fails."
        },
        {
          "name": "summarize_entries_bulk",
          "description": "Generate a summary for a list of text entries using the configured LLM model\nand subcategory-specific prompts.",
          "args": "entries (List[str]): The list of text entries to summarize.\nsubcategory (Optional[str], optional): The subcategory to use for the prompt.",
          "returns": "str: The generated summary or a fallback message if summarization fails."
        }
      ]
    },
    "coverage": {
      "method_diff": {
        "AISummarizer": {
          "missing": [],
          "added": [
            "__init__",
            "_fallback_summary",
            "summarize_entry",
            "summarize_entries_bulk"
          ]
        }
      },
      "missing_tests": [],
      "complexity": {
        "AISummarizer.__init__": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 3,
          "lines": 3,
          "covered_lines": [
            37,
            38,
            39,
            42
          ],
          "missing_lines": []
        },
        "AISummarizer._fallback_summary": {
          "complexity": 3,
          "coverage": 0.6667,
          "hits": 4,
          "lines": 6,
          "covered_lines": [
            55,
            56,
            57,
            60,
            61
          ],
          "missing_lines": []
        },
        "AISummarizer.summarize_entry": {
          "complexity": 3,
          "coverage": 0.75,
          "hits": 6,
          "lines": 8,
          "covered_lines": [
            80,
            83,
            85,
            86,
            87,
            88,
            89
          ],
          "missing_lines": []
        },
        "AISummarizer.summarize_entries_bulk": {
          "complexity": 6,
          "coverage": 1.0,
          "hits": 11,
          "lines": 11,
          "covered_lines": [
            108,
            109,
            110,
            112,
            115,
            116,
            118,
            119,
            120,
            121,
            124,
            125,
            126
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "mypy": {
          "errors": [
            "scripts/ai/ai_summarizer.py:17: error: Library stubs not installed for \"requests.exceptions\"  [import-untyped]",
            "scripts/ai/ai_summarizer.py:81: error: Argument 1 to \"get\" of \"dict\" has incompatible type \"str | None\"; expected \"str\"  [arg-type]",
            "scripts/ai/ai_summarizer.py:113: error: Argument 1 to \"get\" of \"dict\" has incompatible type \"str | None\"; expected \"str\"  [arg-type]"
          ]
        },
        "black": {
          "needs_formatting": true
        },
        "pydocstyle": {
          "functions": {
            "AISummarizer": [
              {
                "code": "D205",
                "message": "1 blank line required between summary line and description (found 0)"
              }
            ],
            "__init__": [
              {
                "code": "D205",
                "message": "1 blank line required between summary line and description (found 0)"
              }
            ],
            "_fallback_summary": [
              {
                "code": "D205",
                "message": "1 blank line required between summary line and description (found 0)"
              }
            ],
            "summarize_entry": [
              {
                "code": "D205",
                "message": "1 blank line required between summary line and description (found 0)"
              }
            ],
            "summarize_entries_bulk": [
              {
                "code": "D205",
                "message": "1 blank line required between summary line and description (found 0)"
              }
            ]
          }
        }
      }
    }
  },
  "ai/chat_refactor.py": {
    "docstrings": {
      "module_doc": {
        "description": "This module provides functionality to load reports and build contextual prompts for an AI assistant.\nIt includes functions to load JSON reports and generate prompts based on the report data and user queries.",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "load_report",
          "description": "Load a JSON report from the specified file path.",
          "args": "path (str): The path to the JSON report file.",
          "returns": "dict: The loaded report data."
        },
        {
          "name": "build_contextual_prompt",
          "description": "Build a contextual prompt for the AI assistant based on the developer's query and report data.",
          "args": "query (str): The developer's question.\nreport_data (dict): The report data containing file information.\nconfig: Configuration object containing persona information.",
          "returns": "str: The constructed prompt for the AI assistant."
        }
      ]
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {
        "load_report": {
          "complexity": 2,
          "coverage": 1.0,
          "hits": 2,
          "lines": 2,
          "covered_lines": [
            22,
            23
          ],
          "missing_lines": []
        },
        "build_contextual_prompt": {
          "complexity": 8,
          "coverage": 1.0,
          "hits": 12,
          "lines": 12,
          "covered_lines": [
            37,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            53,
            63
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "flake8": {
          "issues": [
            {
              "line": 8,
              "column": 1,
              "code": "F401",
              "message": "'scripts.ai.llm_router.get_prompt_template' imported but unused"
            },
            {
              "line": 8,
              "column": 1,
              "code": "F401",
              "message": "'scripts.ai.llm_router.get_prompt_template' imported but unused"
            }
          ]
        },
        "mypy": {
          "errors": [
            "scripts/ai/chat_refactor.py:12: error: Missing type parameters for generic type \"dict\"  [type-arg]",
            "scripts/ai/chat_refactor.py:23: error: Returning Any from function declared to return \"dict[Any, Any]\"  [no-any-return]",
            "scripts/ai/chat_refactor.py:25: error: Function is missing a type annotation for one or more arguments  [no-untyped-def]",
            "scripts/ai/chat_refactor.py:25: error: Missing type parameters for generic type \"dict\"  [type-arg]"
          ]
        },
        "black": {
          "needs_formatting": true
        },
        "coverage": {
          "percent": 80.0
        }
      }
    }
  },
  "ai/llm_optimization.py": {
    "docstrings": {
      "module_doc": {
        "description": "Module for optimizing LLM interactions by summarizing file data\nand generating prompts for refactoring and strategic recommendations.\nAuthor: [Your Name]\nDate: 2025-05-10",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "summarize_file_data_for_llm",
          "description": "Condense file data to essential information for LLM processing.\nThis helps reduce token usage when sending many files.",
          "args": "file_data (dict): The data of the file containing coverage and linting information.\nfile_path (str): The path of the file being summarized.",
          "returns": "dict: A summary of the file data including complexity, coverage, and issues."
        },
        {
          "name": "extract_top_issues",
          "description": "Extract the most important issues from a file.",
          "args": "file_data (dict): The data of the file containing issues.\nmax_issues (int): Maximum number of issues to extract.",
          "returns": "list: A list of the most important issues."
        },
        {
          "name": "build_refactor_prompt",
          "description": "Build a prompt for refactoring suggestions, optimized for handling many files.",
          "args": "offenders: List of (file_path, score, errors, lint_issues, complexity, coverage) tuples\nconfig: Configuration object\nverbose: Whether to include detailed info about each file\nlimit: Maximum number of files to include",
          "returns": "str: A prompt for refactoring suggestions"
        },
        {
          "name": "build_strategic_recommendations_prompt",
          "description": "Build a prompt for strategic recommendations that can handle many files.",
          "args": "severity_data: List of severity data for each file\nsummary_metrics: Dictionary of summary metrics\nlimit: Maximum number of files to include",
          "returns": "str: A prompt for strategic recommendations"
        },
        {
          "name": "compute_severity",
          "description": "Compute severity metrics for a file based on its linting errors, mypy errors,\ncode complexity, and test coverage.",
          "args": "file_path: Path to the file being analyzed\ncontent: Dictionary containing analysis data for the file",
          "returns": "dict: A dictionary with severity metrics"
        }
      ]
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {
        "summarize_file_data_for_llm": {
          "complexity": 7,
          "coverage": 1.0,
          "hits": 10,
          "lines": 10,
          "covered_lines": [
            27,
            28,
            29,
            32,
            33,
            34,
            37,
            38,
            39,
            42
          ],
          "missing_lines": []
        },
        "extract_top_issues": {
          "complexity": 12,
          "coverage": 1.0,
          "hits": 15,
          "lines": 15,
          "covered_lines": [
            63,
            66,
            67,
            69,
            72,
            73,
            74,
            76,
            77,
            78,
            81,
            83,
            84,
            85,
            87
          ],
          "missing_lines": []
        },
        "build_refactor_prompt": {
          "complexity": 12,
          "coverage": 1.0,
          "hits": 11,
          "lines": 11,
          "covered_lines": [
            104,
            106,
            108,
            120,
            126,
            127,
            128,
            130,
            137,
            138,
            140
          ],
          "missing_lines": []
        },
        "build_strategic_recommendations_prompt": {
          "complexity": 7,
          "coverage": 1.0,
          "hits": 15,
          "lines": 15,
          "covered_lines": [
            156,
            159,
            160,
            161,
            163,
            164,
            165,
            166,
            167,
            168,
            169,
            170,
            173,
            179,
            210
          ],
          "missing_lines": []
        },
        "compute_severity": {
          "complexity": 7,
          "coverage": 1.0,
          "hits": 12,
          "lines": 12,
          "covered_lines": [
            225,
            226,
            227,
            228,
            230,
            231,
            233,
            234,
            236,
            237,
            239,
            246
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "mypy": {
          "errors": [
            "scripts/ai/llm_optimization.py:13: error: Missing type parameters for generic type \"dict\"  [type-arg]",
            "scripts/ai/llm_optimization.py:52: error: Missing type parameters for generic type \"dict\"  [type-arg]",
            "scripts/ai/llm_optimization.py:52: error: Missing type parameters for generic type \"list\"  [type-arg]",
            "scripts/ai/llm_optimization.py:63: error: Need type annotation for \"issues\" (hint: \"issues: list[<type>] = ...\")  [var-annotated]",
            "scripts/ai/llm_optimization.py:91: error: Missing type parameters for generic type \"list\"  [type-arg]",
            "scripts/ai/llm_optimization.py:91: error: Missing type parameters for generic type \"dict\"  [type-arg]",
            "scripts/ai/llm_optimization.py:138: error: \"dict[Any, Any]\" has no attribute \"persona\"  [attr-defined]",
            "scripts/ai/llm_optimization.py:144: error: Missing type parameters for generic type \"list\"  [type-arg]",
            "scripts/ai/llm_optimization.py:144: error: Missing type parameters for generic type \"dict\"  [type-arg]",
            "scripts/ai/llm_optimization.py:213: error: Missing type parameters for generic type \"dict\"  [type-arg]"
          ]
        },
        "black": {
          "needs_formatting": true
        },
        "pydocstyle": {
          "functions": {
            "summarize_file_data_for_llm": [
              {
                "code": "D205",
                "message": "1 blank line required between summary line and description (found 0)"
              }
            ],
            "compute_severity": [
              {
                "code": "D205",
                "message": "1 blank line required between summary line and description (found 0)"
              }
            ]
          }
        }
      }
    }
  },
  "ai/llm_refactor_advisor.py": {
    "docstrings": {
      "module_doc": {
        "description": "This module provides functionality to load audit reports and build refactor prompts for an AI assistant.\nIt includes functions to load JSON audit data, extract top offenders based on various metrics, and generate prompts for AI assistance.",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "load_audit",
          "description": "Load a JSON audit report from the specified file path.",
          "args": "path (str): The path to the JSON audit file.",
          "returns": "dict: The loaded audit data."
        },
        {
          "name": "extract_top_offenders",
          "description": "Extract the top offenders from the report data based on various metrics.",
          "args": "report_data (dict): The report data containing file information.\ntop_n (int): The number of top offenders to return.",
          "returns": "list: A sorted list of top offenders with their metrics."
        },
        {
          "name": "build_refactor_prompt",
          "description": "Build a refactor prompt for the AI assistant based on identified offenders.",
          "args": "offenders (list): A list of top offenders with their metrics.\nconfig: Configuration object containing persona information.\nsubcategory (str): The subcategory for the prompt.\nverbose (bool): If True, include more detailed information.\nlimit (int, optional): The maximum number of offenders to include in the prompt. Defaults to None (include all).",
          "returns": "str: The constructed prompt for the AI assistant."
        }
      ]
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {
        "load_audit": {
          "complexity": 2,
          "coverage": 1.0,
          "hits": 2,
          "lines": 2,
          "covered_lines": [
            23,
            24
          ],
          "missing_lines": []
        },
        "extract_top_offenders": {
          "complexity": 9,
          "coverage": 1.0,
          "hits": 13,
          "lines": 13,
          "covered_lines": [
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            47,
            48,
            50,
            52,
            53
          ],
          "missing_lines": []
        },
        "build_refactor_prompt": {
          "complexity": 4,
          "coverage": 0.75,
          "hits": 8,
          "lines": 10,
          "covered_lines": [
            71,
            72,
            75,
            78,
            79,
            80,
            82,
            83
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "flake8": {
          "issues": [
            {
              "line": 95,
              "column": 19,
              "code": "W292",
              "message": "no newline at end of file"
            },
            {
              "line": 95,
              "column": 19,
              "code": "W292",
              "message": "no newline at end of file"
            }
          ]
        },
        "mypy": {
          "errors": [
            "scripts/ai/llm_refactor_advisor.py:13: error: Missing type parameters for generic type \"dict\"  [type-arg]",
            "scripts/ai/llm_refactor_advisor.py:24: error: Returning Any from function declared to return \"dict[Any, Any]\"  [no-any-return]",
            "scripts/ai/llm_refactor_advisor.py:26: error: Missing type parameters for generic type \"dict\"  [type-arg]",
            "scripts/ai/llm_refactor_advisor.py:26: error: Missing type parameters for generic type \"list\"  [type-arg]",
            "scripts/ai/llm_refactor_advisor.py:56: error: Function is missing a type annotation for one or more arguments  [no-untyped-def]",
            "scripts/ai/llm_refactor_advisor.py:56: error: Missing type parameters for generic type \"list\"  [type-arg]",
            "scripts/ai/llm_refactor_advisor.py:57: error: Incompatible default for argument \"limit\" (default has type \"None\", argument has type \"int\")  [assignment]"
          ]
        },
        "black": {
          "needs_formatting": true
        },
        "coverage": {
          "percent": 54.5
        }
      }
    }
  },
  "ai/llm_router.py": {
    "docstrings": {
      "module_doc": {
        "description": "This module provides functionality to retrieve prompt templates and apply personas to prompts for an AI assistant.\nIt includes functions to get prompt templates based on subcategories and modify prompts according to specified personas.",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "get_prompt_template",
          "description": "Retrieve a prompt string for a given subcategory from the configuration.\nFalls back to the default if not found.",
          "args": "subcategory (str): The subcategory for which to retrieve the prompt.\nconfig: Optional configuration object.",
          "returns": "str: The prompt string for the specified subcategory."
        },
        {
          "name": "apply_persona",
          "description": "Optionally tweak the prompt based on the specified persona.",
          "args": "prompt (str): The original prompt string.\npersona (str): The persona to apply to the prompt.",
          "returns": "str: The modified prompt string with persona adjustments."
        }
      ]
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {
        "get_prompt_template": {
          "complexity": 2,
          "coverage": 1.0,
          "hits": 2,
          "lines": 2,
          "covered_lines": [
            21,
            22
          ],
          "missing_lines": []
        },
        "apply_persona": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 2,
          "lines": 2,
          "covered_lines": [
            35,
            41
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "flake8": {
          "issues": [
            {
              "line": 9,
              "column": 1,
              "code": "E302",
              "message": "expected 2 blank lines, found 1"
            },
            {
              "line": 24,
              "column": 1,
              "code": "E302",
              "message": "expected 2 blank lines, found 1"
            },
            {
              "line": 9,
              "column": 1,
              "code": "E302",
              "message": "expected 2 blank lines, found 1"
            },
            {
              "line": 24,
              "column": 1,
              "code": "E302",
              "message": "expected 2 blank lines, found 1"
            }
          ]
        },
        "mypy": {
          "errors": [
            "scripts/ai/llm_router.py:9: error: Function is missing a type annotation for one or more arguments  [no-untyped-def]",
            "scripts/ai/llm_router.py:22: error: Returning Any from function declared to return \"str\"  [no-any-return]"
          ]
        },
        "black": {
          "needs_formatting": true
        },
        "pydocstyle": {
          "functions": {
            "get_prompt_template": [
              {
                "code": "D205",
                "message": "1 blank line required between summary line and description (found 0)"
              }
            ]
          }
        },
        "coverage": {
          "percent": 100.0
        }
      }
    }
  },
  "ai/module_docstring_summarizer.py": {
    "docstrings": {
      "module_doc": {
        "description": "This module provides functionality to load audit reports and build refactor prompts for an AI assistant.\nIt includes functions to load JSON audit data, extract top offenders based on various metrics, and generate prompts for AI assistance.",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "summarize_module",
          "description": "Summarize the module's docstrings using the provided summarizer.",
          "args": "file_path (str): The path to the module file.\ndoc_entries (list): List of docstring entries to summarize.\nsummarizer (AISummarizer): The summarizer instance to use.\nconfig (ConfigManager): The configuration manager instance.",
          "returns": "str: The summary of the module's docstrings."
        },
        {
          "name": "run",
          "description": "Run the summarization process on the specified input file.",
          "args": "input_path (str): The path to the input JSON report file.\noutput_path (str | None): Optional path to save the output summary.\npath_filter (str | None): Optional filter for file paths to include in the summary.",
          "returns": null
        }
      ]
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {
        "summarize_module": {
          "complexity": 4,
          "coverage": 1.0,
          "hits": 12,
          "lines": 12,
          "covered_lines": [
            28,
            29,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40
          ],
          "missing_lines": []
        },
        "run": {
          "complexity": 10,
          "coverage": 0.7667,
          "hits": 15,
          "lines": 20,
          "covered_lines": [
            51,
            52,
            53,
            55,
            56,
            58,
            59,
            61,
            62,
            63,
            64,
            65,
            67,
            73,
            74
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "flake8": {
          "issues": [
            {
              "line": 9,
              "column": 1,
              "code": "F401",
              "message": "'pathlib.Path' imported but unused"
            },
            {
              "line": 72,
              "column": 22,
              "code": "W292",
              "message": "no newline at end of file"
            },
            {
              "line": 9,
              "column": 1,
              "code": "F401",
              "message": "'pathlib.Path' imported but unused"
            },
            {
              "line": 72,
              "column": 22,
              "code": "W292",
              "message": "no newline at end of file"
            }
          ]
        },
        "mypy": {
          "errors": [
            "scripts/ai/module_docstring_summarizer.py:15: error: Missing type parameters for generic type \"list\"  [type-arg]",
            "scripts/ai/module_docstring_summarizer.py:39: error: \"ConfigManager\" has no attribute \"persona\"  [attr-defined]",
            "scripts/ai/module_docstring_summarizer.py:64: error: Argument 4 to \"summarize_module\" has incompatible type \"AppConfig\"; expected \"ConfigManager\"  [arg-type]"
          ]
        },
        "black": {
          "needs_formatting": true
        },
        "coverage": {
          "percent": 37.5
        }
      }
    }
  },
  "ci_analyzer/__init__.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": []
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {}
    },
    "linting": {
      "quality": {
        "coverage": {
          "percent": 100.0
        }
      }
    }
  },
  "ci_analyzer/drilldown.py": {
    "docstrings": {
      "module_doc": {
        "description": "This module provides functionality to generate detailed Markdown reports for top offenders in code quality analysis.\nIt includes functions to create drilldowns that summarize linting errors, complexity, coverage, and function descriptions for the top offenders.",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "generate_top_offender_drilldowns",
          "description": "Generate a Markdown section with drilldowns for the top N offenders.",
          "args": "severity_df: DataFrame containing severity information for files.\nreport_data (dict): Dictionary containing report data for each file.\ntop_n (int): Number of top offenders to include in the report.",
          "returns": "str: Markdown formatted string with detailed analysis of top offenders."
        }
      ]
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {
        "generate_top_offender_drilldowns": {
          "complexity": 13,
          "coverage": 1.0,
          "hits": 35,
          "lines": 35,
          "covered_lines": [
            20,
            21,
            23,
            24,
            25,
            28,
            29,
            30,
            31,
            32,
            35,
            36,
            37,
            38,
            39,
            40,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            63,
            65
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "mypy": {
          "errors": [
            "scripts/ci_analyzer/drilldown.py:8: error: Function is missing a type annotation for one or more arguments  [no-untyped-def]",
            "scripts/ci_analyzer/drilldown.py:8: error: Missing type parameters for generic type \"dict\"  [type-arg]"
          ]
        },
        "black": {
          "needs_formatting": true
        }
      }
    }
  },
  "ci_analyzer/metrics_summary.py": {
    "docstrings": {
      "module_doc": {
        "description": "This module provides functionality to generate summary metrics from code quality reports.\nIt includes functions to analyze report data and summarize key metrics related to methods, tests, complexity, docstrings, and linter issues.",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "generate_metrics_summary",
          "description": "Generate a summary of metrics from the provided report data.",
          "args": "report_data (dict): Dictionary containing report data for each file.",
          "returns": "str: A Markdown formatted string summarizing the metrics."
        }
      ]
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {
        "generate_metrics_summary": {
          "complexity": 10,
          "coverage": 1.0,
          "hits": 19,
          "lines": 19,
          "covered_lines": [
            18,
            19,
            20,
            21,
            22,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            32,
            33,
            34,
            36,
            37,
            38,
            40
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "mypy": {
          "errors": [
            "scripts/ci_analyzer/metrics_summary.py:8: error: Missing type parameters for generic type \"dict\"  [type-arg]"
          ]
        },
        "black": {
          "needs_formatting": true
        }
      }
    }
  },
  "ci_analyzer/severity_audit.py": {
    "docstrings": {
      "module_doc": {
        "description": "This module provides functionality to generate a CI code quality audit report.\nIt includes functions to format priority levels and generate summary header blocks based on severity metrics.",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "format_priority",
          "description": "Format the priority level based on the severity score.",
          "args": "score (float): The severity score to evaluate.",
          "returns": "str: A string representing the priority level (High, Medium, Low)."
        },
        {
          "name": "generate_header_block",
          "description": "Generate a header block for the CI code quality audit report.",
          "args": "severity_df: DataFrame containing severity information for files.\nreport_data: Dictionary containing report data for each file.",
          "returns": "str: A Markdown formatted string representing the header block."
        },
        {
          "name": "generate_severity_table",
          "description": "Generate a severity table for the CI code quality audit report.",
          "args": "severity_df: DataFrame containing severity information for files.",
          "returns": "str: A Markdown formatted string representing the severity table."
        },
        {
          "name": "main",
          "description": "Generate a CI code quality audit report.\nThis function parses command line arguments, loads report data, computes severity metrics,\nand generates a Markdown report.",
          "args": null,
          "returns": null
        }
      ]
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {
        "format_priority": {
          "complexity": 3,
          "coverage": 1.0,
          "hits": 5,
          "lines": 5,
          "covered_lines": [
            27,
            28,
            29,
            30,
            32
          ],
          "missing_lines": []
        },
        "generate_header_block": {
          "complexity": 9,
          "coverage": 1.0,
          "hits": 19,
          "lines": 19,
          "covered_lines": [
            45,
            46,
            49,
            52,
            53,
            54,
            55,
            57,
            58,
            59,
            60,
            62,
            67,
            68,
            69,
            71,
            72,
            73,
            75
          ],
          "missing_lines": []
        },
        "generate_severity_table": {
          "complexity": 3,
          "coverage": 1.0,
          "hits": 12,
          "lines": 12,
          "covered_lines": [
            101,
            102,
            103,
            106,
            107,
            108,
            110,
            111,
            112,
            113,
            114,
            119
          ],
          "missing_lines": []
        },
        "main": {
          "complexity": 2,
          "coverage": 1.0,
          "hits": 12,
          "lines": 12,
          "covered_lines": [
            129,
            130,
            131,
            132,
            133,
            135,
            136,
            138,
            140,
            147,
            148,
            149
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "flake8": {
          "issues": [
            {
              "line": 155,
              "column": 11,
              "code": "W292",
              "message": "no newline at end of file"
            },
            {
              "line": 155,
              "column": 11,
              "code": "W292",
              "message": "no newline at end of file"
            }
          ]
        },
        "mypy": {
          "errors": [
            "scripts/ci_analyzer/severity_audit.py:34: error: Function is missing a type annotation for one or more arguments  [no-untyped-def]",
            "scripts/ci_analyzer/severity_audit.py:34: error: Missing type parameters for generic type \"Dict\"  [type-arg]",
            "scripts/ci_analyzer/severity_audit.py:91: error: Function is missing a type annotation for one or more arguments  [no-untyped-def]"
          ]
        },
        "black": {
          "needs_formatting": true
        },
        "coverage": {
          "percent": 58.3
        }
      }
    }
  },
  "ci_analyzer/severity_index.py": {
    "docstrings": {
      "module_doc": {
        "description": "This module provides functionality to compute severity scores for code quality analysis.\nIt includes functions to compute individual severity scores for files and to create a severity index DataFrame from report data.",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "compute_severity",
          "description": "Compute the severity score for a given file based on its coverage and linting data.",
          "args": "file_path (str): The path of the file being analyzed.\ncontent (dict): The report data for the file, including coverage and linting information.",
          "returns": "dict: A dictionary containing the severity metrics for the file."
        },
        {
          "name": "compute_severity_index",
          "description": "Compute a severity index for all files in the report data.",
          "args": "report_data (dict): Dictionary containing report data for each file.",
          "returns": "pd.DataFrame: A DataFrame sorted by severity score."
        }
      ]
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {
        "compute_severity": {
          "complexity": 7,
          "coverage": 1.0,
          "hits": 12,
          "lines": 12,
          "covered_lines": [
            22,
            23,
            24,
            25,
            27,
            28,
            30,
            31,
            33,
            34,
            37,
            44
          ],
          "missing_lines": []
        },
        "compute_severity_index": {
          "complexity": 4,
          "coverage": 1.0,
          "hits": 5,
          "lines": 5,
          "covered_lines": [
            63,
            66,
            67,
            71,
            72
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "flake8": {
          "issues": [
            {
              "line": 11,
              "column": 1,
              "code": "E302",
              "message": "expected 2 blank lines, found 1"
            },
            {
              "line": 52,
              "column": 1,
              "code": "E302",
              "message": "expected 2 blank lines, found 1"
            },
            {
              "line": 71,
              "column": 87,
              "code": "W292",
              "message": "no newline at end of file"
            },
            {
              "line": 11,
              "column": 1,
              "code": "E302",
              "message": "expected 2 blank lines, found 1"
            },
            {
              "line": 52,
              "column": 1,
              "code": "E302",
              "message": "expected 2 blank lines, found 1"
            },
            {
              "line": 71,
              "column": 87,
              "code": "W292",
              "message": "no newline at end of file"
            }
          ]
        },
        "mypy": {
          "errors": [
            "scripts/ci_analyzer/severity_index.py:11: error: Missing type parameters for generic type \"dict\"  [type-arg]",
            "scripts/ci_analyzer/severity_index.py:53: error: Missing type parameters for generic type \"dict\"  [type-arg]"
          ]
        },
        "black": {
          "needs_formatting": true
        },
        "coverage": {
          "percent": 81.0
        }
      }
    }
  },
  "ci_analyzer/visuals.py": {
    "docstrings": {
      "module_doc": {
        "description": "This module provides functionality to render visual representations of risk and scores for code quality analysis.\nIt includes functions to generate risk emojis and bar representations based on severity scores.",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "risk_emoji",
          "description": "Return an emoji representing the risk level based on the severity score.",
          "args": "score (float): The severity score to evaluate.",
          "returns": "str: An emoji indicating the risk level (green, yellow, or red)."
        },
        {
          "name": "render_bar",
          "description": "Render a horizontal bar representation of the score.",
          "args": "score (float): The score to represent as a bar.\nwidth (int): The total width of the bar (default is 20).",
          "returns": "str: A string representing the filled and unfilled sections of the bar."
        }
      ]
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {
        "risk_emoji": {
          "complexity": 3,
          "coverage": 0.25,
          "hits": 4,
          "lines": 16,
          "covered_lines": [],
          "missing_lines": [
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            22
          ]
        },
        "render_bar": {
          "complexity": 1,
          "coverage": 0.6923,
          "hits": 9,
          "lines": 13,
          "covered_lines": [],
          "missing_lines": [
            26,
            27,
            33,
            34
          ]
        }
      }
    },
    "linting": {
      "quality": {
        "black": {
          "needs_formatting": true
        }
      }
    }
  },
  "config/__init__.py": {
    "docstrings": {
      "module_doc": {
        "description": "The `config` module centralizes application configuration management and logging setup.\nCore features include:\n- Loading, validating, and caching application settings from JSON configuration files.\n- Providing a Pydantic-based configuration model for type-safe access to settings.\n- Managing environment-specific and test-mode configurations.\n- Utilities for safe file reading and error handling during configuration loading.\n- Centralized logging setup for consistent application-wide logging behavior.\nThis module ensures robust, maintainable, and flexible configuration and logging for the entire application.",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": []
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {}
    },
    "linting": {
      "quality": {
        "coverage": {
          "percent": 100.0
        }
      }
    }
  },
  "config/config_loader.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "setup_logging",
          "description": "Configure centralized logging.\nThis function sets up the logging level, format, and handlers for the application.",
          "args": null,
          "returns": "None\nRaises:\nNone"
        },
        {
          "name": "load_config",
          "description": "Safely load the configuration file from the specified path.\nIf the config file does not exist or has errors, return an empty dictionary.",
          "args": "config_path (Optional[Path]): The path to the config file. If None, defaults to CONFIG_FILE_PATH.",
          "returns": "Dict[str, Any]: The loaded configuration dictionary, or an empty dictionary if loading fails.\nRaises:\nFileNotFoundError: If the configuration file cannot be found.\nJSONDecodeError: If the configuration file contains invalid JSON."
        },
        {
          "name": "get_config_value",
          "description": "Retrieve a configuration value by its key from the provided config dictionary.\nIf the key is not found in the config, a warning is logged and the default value is returned.",
          "args": "config (Dict[str, Any]): The configuration dictionary.\nkey (str): The key of the value to retrieve.\ndefault (Any): The default value to return if the key is not found.",
          "returns": "Any: The retrieved configuration value or the default value.\nRaises:\nKeyError: If the key is not found and no default is provided."
        },
        {
          "name": "get_absolute_path",
          "description": "Build an absolute path from a project-root-relative path.",
          "args": "relative_path (str): The relative path to convert.",
          "returns": "Path: The absolute path derived from the project root.\nRaises:\nValueError: If the relative path is invalid."
        },
        {
          "name": "is_test_mode",
          "description": "Check if 'test_mode' is enabled in the configuration.",
          "args": "config (Optional[Dict[str, Any]]): The configuration dictionary. If None, defaults to loading the config.",
          "returns": "bool: True if 'test_mode' is enabled, False otherwise.\nRaises:\nRuntimeError: If the configuration cannot be loaded."
        },
        {
          "name": "get_effective_config",
          "description": "Load the configuration from the specified path and override paths with test-safe ones if 'test_mode' is enabled.\nThis function first attempts to load the configuration from the given path. If 'test_mode' is active, it modifies certain paths in the configuration to point to test-safe equivalents, ensuring that tests do not interfere with production data.",
          "args": "config_path (Optional[Path]): The path to the config file. If None, defaults to CONFIG_FILE_PATH.",
          "returns": "Dict[str, Any]: The effective configuration dictionary, with test-safe paths if applicable.\nRaises:\nFileNotFoundError: If the configuration file cannot be found.\nJSONDecodeError: If the configuration file contains invalid JSON."
        }
      ]
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {
        "setup_logging": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 3,
          "lines": 3,
          "covered_lines": [
            21,
            22,
            23,
            28
          ],
          "missing_lines": []
        },
        "load_config": {
          "complexity": 7,
          "coverage": 0.6364,
          "hits": 7,
          "lines": 11,
          "covered_lines": [
            53,
            54,
            55,
            57,
            58,
            59,
            60,
            61,
            63,
            64,
            65,
            67,
            69
          ],
          "missing_lines": []
        },
        "get_config_value": {
          "complexity": 2,
          "coverage": 1.0,
          "hits": 3,
          "lines": 3,
          "covered_lines": [
            96,
            97,
            98,
            99
          ],
          "missing_lines": []
        },
        "get_absolute_path": {
          "complexity": 3,
          "coverage": 0.5,
          "hits": 2,
          "lines": 4,
          "covered_lines": [
            115,
            116
          ],
          "missing_lines": []
        },
        "is_test_mode": {
          "complexity": 2,
          "coverage": 0.0,
          "hits": 0,
          "lines": 3,
          "covered_lines": [],
          "missing_lines": []
        },
        "get_effective_config": {
          "complexity": 4,
          "coverage": 0.9091,
          "hits": 10,
          "lines": 11,
          "covered_lines": [
            156,
            157,
            158,
            159,
            163,
            164,
            167,
            169,
            170,
            171,
            175
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "mypy": {
          "errors": [
            "scripts/config/config_loader.py:69: error: Returning Any from function declared to return \"dict[str, Any]\"  [no-any-return]",
            "scripts/config/config_loader.py:137: error: Returning Any from function declared to return \"bool\"  [no-any-return]"
          ]
        },
        "black": {
          "needs_formatting": true
        }
      }
    }
  },
  "config/config_manager.py": {
    "docstrings": {
      "module_doc": {
        "description": "config_manager.py\nThis module provides centralized management of application configuration using a Pydantic-based model.\nCore features include:\n- Defining a comprehensive AppConfig model for all configurable application parameters.\n- Loading, validating, and caching configuration from a JSON file.\n- Utility methods for retrieving configuration values, resetting the config cache, and validating critical config paths.\n- Integration with safe file reading utilities for resilience against missing or malformed config files.\nIntended for use throughout the application to ensure consistent, validated configuration management.",
        "args": null,
        "returns": null
      },
      "classes": [
        {
          "name": "AppConfig",
          "description": "Configuration model for application settings.\nDefines all configurable parameters for the application, including UI,\nlogging, LLM and embedding model settings, file paths, test mode,\nand plugin management. Ignores any extra fields not explicitly defined.",
          "args": null,
          "returns": null
        },
        {
          "name": "Config",
          "description": null,
          "args": null,
          "returns": null
        },
        {
          "name": "ConfigManager",
          "description": "Manages application configuration loading, caching, and validation.\nProvides methods to load configuration from a JSON file using the AppConfig model,\nretrieve configuration values, reset the cached config, and validate critical config paths.\nHandles missing or invalid config files by returning default settings and logs relevant events.",
          "args": null,
          "returns": null
        }
      ],
      "functions": [
        {
          "name": "_default_config",
          "description": "Return a fresh copy of the pre-instantiated default config.",
          "args": null,
          "returns": null
        },
        {
          "name": "load_config",
          "description": "Loads the application configuration from a JSON file, with optional cache refresh.\nIf the config file is missing or invalid, returns a default AppConfig instance.\nCaches the loaded config and reloads if the file changes or force_reload is True.\nLogs relevant events and raises on validation errors.",
          "args": "config_path (str): Path to the configuration JSON file.\nforce_reload (bool): If True, forces reloading the config from disk.",
          "returns": "AppConfig: The loaded or default application configuration."
        },
        {
          "name": "get_value",
          "description": "Retrieve a configuration value by key from the loaded AppConfig.",
          "args": "key (str): The configuration attribute to retrieve.\ndefault (Any, optional): Value to return if the key is not found. Defaults to None.\nforce_reload (bool, optional): If True, reloads the config from disk. Defaults to False.",
          "returns": "Any: The value of the requested configuration key, or the default if not found."
        },
        {
          "name": "reset",
          "description": "Reset the cached configuration and timestamp.",
          "args": null,
          "returns": null
        },
        {
          "name": "validate_config_paths",
          "description": "Validate that critical config paths have existing parent directories.\nLogs a warning for each missing directory. Returns True if all required directories exist, otherwise False.",
          "args": null,
          "returns": "bool: True if all critical directories exist, False otherwise."
        }
      ]
    },
    "coverage": {
      "method_diff": {
        "AppConfig": {
          "missing": [],
          "added": []
        },
        "Config": {
          "missing": [],
          "added": []
        },
        "ConfigManager": {
          "missing": [],
          "added": [
            "_default_config",
            "load_config",
            "get_value",
            "reset",
            "validate_config_paths"
          ]
        }
      },
      "missing_tests": [],
      "complexity": {
        "ConfigManager._default_config": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 1,
          "lines": 1,
          "covered_lines": [
            142
          ],
          "missing_lines": []
        },
        "ConfigManager.load_config": {
          "complexity": 11,
          "coverage": 0.9,
          "hits": 18,
          "lines": 20,
          "covered_lines": [
            162,
            164,
            170,
            171,
            172,
            174,
            175,
            176,
            177,
            178,
            179,
            180,
            181,
            182,
            186,
            187,
            188,
            189,
            192,
            193,
            194,
            196,
            198
          ],
          "missing_lines": []
        },
        "ConfigManager.get_value": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 2,
          "lines": 2,
          "covered_lines": [
            213,
            214
          ],
          "missing_lines": []
        },
        "ConfigManager.reset": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 2,
          "lines": 2,
          "covered_lines": [
            219,
            220,
            221
          ],
          "missing_lines": []
        },
        "ConfigManager.validate_config_paths": {
          "complexity": 4,
          "coverage": 0.0,
          "hits": 0,
          "lines": 5,
          "covered_lines": [],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "black": {
          "needs_formatting": true
        }
      }
    }
  },
  "config/constants.py": {
    "docstrings": {
      "module_doc": {
        "description": "constants.py\nThis module defines global constants used throughout the Zephyrus Logger application.\nCore features include:\n- Timestamp and date formatting strings for consistent time representation.\n- Standardized JSON keys for batch processing, summaries, and content tracking.\n- Keys for summary tracking and logging statistics.\n- Default configuration values for batch size, autosave interval, and log level.\n- Default file suffixes and extensions for summary and markdown files.\n- Centralized UI default settings, such as theme.\nIntended to provide a single source of truth for application-wide constants, improving maintainability and consistency.",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": []
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {}
    },
    "linting": {
      "quality": {
        "coverage": {
          "percent": 100.0
        }
      }
    }
  },
  "config/logging_setup.py": {
    "docstrings": {
      "module_doc": {
        "description": "logging_setup.py\nThis module provides centralized logging configuration for the application.\nCore features include:\n- Defining a `setup_logging` function to initialize the root logger with a specified log level.\n- Clearing existing handlers and adding a console handler with a standardized log message format.\n- Automatically configuring logging upon import for convenience and consistency across the application.\nIntended for use as the standard logging setup to ensure uniform log formatting and log level management.",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "setup_logging",
          "description": "Sets up application-wide logging configuration.\nInitializes the root logger with the specified log level, clears existing handlers,\nand adds a console handler with a standard log message format.",
          "args": "log_level (str): Logging level as a string (e.g., \"INFO\", \"DEBUG\"). Defaults to \"INFO\".",
          "returns": null
        }
      ]
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {
        "setup_logging": {
          "complexity": 2,
          "coverage": 1.0,
          "hits": 3,
          "lines": 3,
          "covered_lines": [
            21,
            22,
            23,
            28
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "mypy": {
          "errors": [
            "scripts/config/logging_setup.py:17: error: Function is missing a type annotation  [no-untyped-def]",
            "scripts/config/logging_setup.py:43: error: Call to untyped function \"setup_logging\" in typed context  [no-untyped-call]"
          ]
        },
        "black": {
          "needs_formatting": true
        }
      }
    }
  },
  "core/__init__.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": []
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {}
    },
    "linting": {
      "quality": {
        "coverage": {
          "percent": 100.0
        }
      }
    }
  },
  "core/core.py": {
    "docstrings": {
      "module_doc": {
        "description": "Core module for Zephyrus Logger\n================================\nThis refactored **core.py** wires together the new, slimmer helper\nmodules we just introduced (`EnvironmentBootstrapper`, `LogManager`,\n`MarkdownLogger`, `SummaryTracker`, `SummaryEngine`). It restores the\npublic surface that the unit & integration tests expect while keeping\nthe implementation focused and declarative.\nKey public methods / attributes re-exposed\n-----------------------------------------\n* **save_entry**           add a new idea to JSON + Markdown & update tracker\n* **log_new_entry**        alias of *save_entry* (used by integration tests)\n* **generate_global_summary**  force batch summarisation via `SummaryEngine`\n* **generate_summary**     backward-compat shim (date arg ignored)\n* **search_summaries** / **search_raw_logs**  thin wrappers around the FAISS\nindexers (gracefully degrade to empty list when indices are disabled in\ntests)\n* **BATCH_SIZE**           pulled from config with sane default so tests can\nuse it directly.\nEverything else (bootstrap, validation, etc.) stays untouched aside from\nswapping our bespoke `_initialize_environment` with the clearer\n`EnvironmentBootstrapper`.",
        "args": null,
        "returns": null
      },
      "classes": [
        {
          "name": "ZephyrusLoggerCore",
          "description": "High-level faade that ties together logging, summarizing, and search functionalities.\nThis class serves as the main interface for managing logs, generating summaries,\nand searching through entries within the Zephyrus Logger application. It initializes\nvarious components necessary for logging and summarization, ensuring the environment\nis properly set up.\nAttributes:\nTIMESTAMP_FORMAT (str): Format for timestamps in logs.\nDATE_FORMAT (str): Format for dates in logs.\nBATCH_KEY (str): Key for batch processing.\nORIGINAL_SUMMARY_KEY (str): Key for original summaries.\nCORRECTED_SUMMARY_KEY (str): Key for corrected summaries.\nCORRECTION_TIMESTAMP_KEY (str): Key for correction timestamps.\nCONTENT_KEY (str): Key for content in logs.\nTIMESTAMP_KEY (str): Key for timestamps in logs.\nBATCH_SIZE (int): Number of entries to process in a batch.\nai_summarizer (AISummarizer): Instance of the AI summarizer.\nlog_manager (LogManager): Instance of the log manager.\nmd_logger (MarkdownLogger): Instance of the markdown logger.\nsummary_tracker (SummaryTracker): Instance of the summary tracker.\nsummary_engine (SummaryEngine): Instance of the summary engine.",
          "args": null,
          "returns": null
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "description": "Initializes the ZephyrusLoggerCore with necessary configurations and collaborators.",
          "args": "script_dir (Union[str, Path]): The directory of the script, used to resolve paths.\nThis constructor performs the following actions:\n1) Loads the effective configuration and resolves all required paths using ZephyrusPaths.\n2) Ensures the necessary on-disk environment (directories and baseline files) is set up.\n3) Instantiates core runtime collaborators including AISummarizer, LogManager, MarkdownLogger,\nSummaryTracker, and SummaryEngine, with configurations like batch size and timestamp format.\n4) Validates the SummaryTracker and optionally rebuilds it if configured to do so or if validation fails.",
          "returns": null
        },
        {
          "name": "save_entry",
          "description": "Saves a new log entry to the JSON log and Markdown export (if enabled).",
          "args": "main_category (str): The main category of the log entry.\nsubcategory (str): The subcategory of the log entry.\nentry (str): The content of the log entry.",
          "returns": "bool: True if the Markdown export succeeded, False otherwise."
        },
        {
          "name": "generate_global_summary",
          "description": "Force a batch summarisation for *main_category  subcategory*.",
          "args": "main_category (str): The main category.\nsubcategory (str): The subcategory.",
          "returns": "bool: The success flag."
        },
        {
          "name": "generate_summary",
          "description": "Backwards-compatibility shim for unit-tests that still pass a *date* arg.\nForce a batch summarisation for *main_category  subcategory*.",
          "args": null,
          "returns": null
        },
        {
          "name": "_safe_search",
          "description": "Perform a search against a FAISS indexer safely, ignoring any exceptions.",
          "args": "indexer_attr (str): The attribute name of the SummaryIndexer instance to query.\nquery (str): The search query.\ntop_k (int): The number of results to return.",
          "returns": "List[Any]: A list of search results, possibly empty."
        },
        {
          "name": "search_summaries",
          "description": "Performs a vector search over summary entries using the FAISS index.",
          "args": "query (str): The search query.\ntop_k (int, optional): The number of top results to return. Defaults to 5.",
          "returns": "List[Any]: A list of the top-k search results."
        },
        {
          "name": "search_raw_logs",
          "description": "Performs a vector search over raw log entries using the FAISS index.",
          "args": "query (str): The search query.\ntop_k (int, optional): The number of top results to return. Defaults to 5.",
          "returns": "List[Any]: A list of the top-k search results."
        },
        {
          "name": "_safe_read_json",
          "description": "Robustly reads a JSON file into a dictionary, returning an empty dict if any errors occur.\nThis helper is used internally, e.g. when loading the tracker's state from disk.\n:param filepath: Path to the JSON file to read.\n:return: The deserialised JSON data as a dictionary.",
          "args": null,
          "returns": null
        }
      ]
    },
    "coverage": {
      "method_diff": {
        "ZephyrusLoggerCore": {
          "missing": [],
          "added": [
            "__init__",
            "save_entry",
            "generate_global_summary",
            "generate_summary",
            "_safe_search",
            "search_summaries",
            "search_raw_logs",
            "_safe_read_json"
          ]
        }
      },
      "missing_tests": [],
      "complexity": {
        "ZephyrusLoggerCore.__init__": {
          "complexity": 4,
          "coverage": 0.875,
          "hits": 13,
          "lines": 14,
          "covered_lines": [
            103,
            104,
            105,
            108,
            111,
            112,
            113,
            121,
            122,
            123,
            134,
            135,
            136,
            137
          ],
          "missing_lines": []
        },
        "ZephyrusLoggerCore.save_entry": {
          "complexity": 3,
          "coverage": 0.7143,
          "hits": 5,
          "lines": 7,
          "covered_lines": [
            155,
            156,
            157,
            158,
            159,
            160
          ],
          "missing_lines": []
        },
        "ZephyrusLoggerCore.generate_global_summary": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 1,
          "lines": 1,
          "covered_lines": [
            182
          ],
          "missing_lines": []
        },
        "ZephyrusLoggerCore.generate_summary": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 1,
          "lines": 1,
          "covered_lines": [
            191
          ],
          "missing_lines": []
        },
        "ZephyrusLoggerCore._safe_search": {
          "complexity": 5,
          "coverage": 0.7143,
          "hits": 4,
          "lines": 5,
          "covered_lines": [
            208,
            209,
            210,
            211
          ],
          "missing_lines": []
        },
        "ZephyrusLoggerCore.search_summaries": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 1,
          "lines": 1,
          "covered_lines": [
            227
          ],
          "missing_lines": []
        },
        "ZephyrusLoggerCore.search_raw_logs": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 1,
          "lines": 1,
          "covered_lines": [
            240
          ],
          "missing_lines": []
        },
        "ZephyrusLoggerCore._safe_read_json": {
          "complexity": 3,
          "coverage": 0.0,
          "hits": 0,
          "lines": 4,
          "covered_lines": [],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "mypy": {
          "errors": [
            "scripts/core/core.py:211: error: Unused \"type: ignore\" comment  [unused-ignore]",
            "scripts/core/core.py:211: error: Returning Any from function declared to return \"list[Any]\"  [no-any-return]"
          ]
        },
        "black": {
          "needs_formatting": true
        },
        "pydocstyle": {
          "functions": {
            "ZephyrusLoggerCore": [
              {
                "code": "D208",
                "message": "Docstring is over-indented"
              }
            ]
          }
        }
      }
    }
  },
  "core/core_cli.py": {
    "docstrings": {
      "module_doc": {
        "description": "Command Line Interface for Zephyrus Logger\n===============================\nThis module provides a command-line interface for the Zephyrus Logger application,\nallowing users to log entries, summarize categories, and search through logs.",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "log",
          "description": "Log a new entry to JSON and Markdown.\nParameters:\nmain (str): The main category for the log entry.\nsub (str): The subcategory for the log entry.\nentry (str): The content of the log entry.",
          "args": null,
          "returns": null
        },
        {
          "name": "summarize",
          "description": "Force summarization of a category/subcategory.\nParameters:\nmain (str): The main category for the summary.\nsub (str): The subcategory for the summary.",
          "args": null,
          "returns": null
        },
        {
          "name": "search",
          "description": "Search summaries or raw logs.\nParameters:\nquery (str): The search query.\ntop_k (int): The number of top results to return.\nkind (str): The type of search ('summary' or 'raw').",
          "args": null,
          "returns": null
        }
      ]
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {
        "log": {
          "complexity": 2,
          "coverage": 0.0,
          "hits": 0,
          "lines": 3,
          "covered_lines": [],
          "missing_lines": []
        },
        "summarize": {
          "complexity": 2,
          "coverage": 0.0,
          "hits": 0,
          "lines": 3,
          "covered_lines": [],
          "missing_lines": []
        },
        "search": {
          "complexity": 2,
          "coverage": 0.0,
          "hits": 0,
          "lines": 3,
          "covered_lines": [],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "black": {
          "needs_formatting": true
        }
      }
    }
  },
  "core/environment_bootstrapper.py": {
    "docstrings": {
      "module_doc": {
        "description": "Environment Bootstrapper Module\n===============================\nThis module provides the EnvironmentBootstrapper class, which is responsible\nfor setting up the necessary directories and files for the Zephyrus Logger\napplication. It ensures that all required resources are in place before\nthe application starts.",
        "args": null,
        "returns": null
      },
      "classes": [
        {
          "name": "EnvironmentBootstrapper",
          "description": "A class to bootstrap the environment for the Zephyrus Logger application.\nThis class handles the creation of necessary directories and files,\nensuring that the application has all required resources available.\nAttributes:\npaths (ZephyrusPaths): An instance containing paths for logs, exports,\nand configuration files.\ndefault_batch_size (int): The default batch size to use if the\nconfiguration file is missing.",
          "args": null,
          "returns": null
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "description": "Initialize the EnvironmentBootstrapper.\nParameters:\npaths (ZephyrusPaths): The paths object containing locations for\nlogs, exports, and configuration.\ndefault_batch_size (int): The default batch size for processing\nentries. Defaults to 5.",
          "args": null,
          "returns": null
        },
        {
          "name": "bootstrap",
          "description": "Bootstrap the environment by creating necessary directories and\ninitializing required files.",
          "args": null,
          "returns": null
        },
        {
          "name": "_make_directories",
          "description": "Create necessary directories for logs and exports.",
          "args": null,
          "returns": null
        },
        {
          "name": "_initialize_files",
          "description": "Initialize log and configuration files. Creates empty files if they\ndo not exist and sets up default values where necessary.",
          "args": null,
          "returns": null
        }
      ]
    },
    "coverage": {
      "method_diff": {
        "EnvironmentBootstrapper": {
          "missing": [],
          "added": [
            "__init__",
            "bootstrap",
            "_make_directories",
            "_initialize_files"
          ]
        }
      },
      "missing_tests": [],
      "complexity": {
        "EnvironmentBootstrapper.__init__": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 2,
          "lines": 2,
          "covered_lines": [
            41,
            42
          ],
          "missing_lines": []
        },
        "EnvironmentBootstrapper.bootstrap": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 2,
          "lines": 2,
          "covered_lines": [
            49,
            50
          ],
          "missing_lines": []
        },
        "EnvironmentBootstrapper._make_directories": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 3,
          "lines": 3,
          "covered_lines": [
            56,
            57,
            58
          ],
          "missing_lines": []
        },
        "EnvironmentBootstrapper._initialize_files": {
          "complexity": 6,
          "coverage": 0.6667,
          "hits": 7,
          "lines": 10,
          "covered_lines": [
            65,
            69,
            70,
            72,
            75,
            79,
            80,
            81
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "black": {
          "needs_formatting": true
        },
        "pydocstyle": {
          "functions": {
            "bootstrap": [
              {
                "code": "D205",
                "message": "1 blank line required between summary line and description (found 0)"
              }
            ],
            "_make_directories": [
              {
                "code": "D200",
                "message": "One-line docstring should fit on one line with quotes (found 3)"
              }
            ],
            "_initialize_files": [
              {
                "code": "D205",
                "message": "1 blank line required between summary line and description (found 0)"
              }
            ]
          }
        }
      }
    }
  },
  "core/log_manager.py": {
    "docstrings": {
      "module_doc": {
        "description": "log_manager.py\nThis module provides the LogManager class for managing log entries and correction summaries.\nIt includes functionality for reading and writing log data in both JSON and plain text formats,\nas well as handling timestamps and content keys for structured logging. The LogManager is essential\nfor the Zephyrus Logger application to maintain a reliable logging system.\nDependencies:\n- pathlib\n- datetime\n- logging\n- scripts.utils.file_utils",
        "args": null,
        "returns": null
      },
      "classes": [
        {
          "name": "LogManager",
          "description": null,
          "args": null,
          "returns": null
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "description": "Initializes a LogManager instance.",
          "args": "json_log_file (Path): Path to the JSON file that stores log entries.\ntxt_log_file (Path): Path to the text file that stores log entries in plain text.\ncorrection_summaries_file (Path): Path to the JSON file that stores correction summaries.\ntimestamp_format (str): Timestamp format for log entries.\ncontent_key (str): Key used to store the content of a log entry in the JSON file.\ntimestamp_key (str): Key used to store the timestamp of a log entry in the JSON file.",
          "returns": null
        },
        {
          "name": "_safe_read_or_create_json",
          "description": "Safely reads a JSON file or creates it if it doesn't exist.\nIf the file doesn't exist, it will create an empty JSON object.",
          "args": "filepath (Path): Path to the JSON file.",
          "returns": "dict: The parsed JSON data or an empty dictionary if the file couldn't be loaded."
        },
        {
          "name": "read_logs",
          "description": "Reads the JSON log file and returns its contents. If the file doesn't exist, it will create an empty JSON object.",
          "args": null,
          "returns": "dict: The parsed JSON data or an empty dictionary if the file couldn't be loaded."
        },
        {
          "name": "update_logs",
          "description": "Updates the JSON log file with the provided update function.\nThe update function will be provided with the current JSON data as a dictionary.\nThe function should modify the dictionary in-place as needed.",
          "args": "update_func (Callable[[dict], None]): The function to call to update the JSON data.",
          "returns": null
        },
        {
          "name": "append_entry",
          "description": "Appends a new log entry to the JSON log file.",
          "args": "date_str (str): The date of the log entry in the format specified by `timestamp_format`.\nmain_category (str): The main category of the log entry.\nsubcategory (str): The subcategory of the log entry.\nentry (str): The content of the log entry.",
          "returns": null
        },
        {
          "name": "updater",
          "description": "Updates the JSON data to append a new log entry.",
          "args": "data (dict): The current JSON data.",
          "returns": null
        },
        {
          "name": "get_unsummarized_batch",
          "description": "Retrieves a batch of unsummarized log entries for the given main category and subcategory.",
          "args": "main_category (str): The main category of the log entries.\nsubcategory (str): The subcategory of the log entries.\nsummarized_total (int): The total number of log entries that have already been summarized.\nbatch_size (int): The number of unsummarized log entries to retrieve in the batch.",
          "returns": "list: A list of log entries, each represented as a dictionary with 'timestamp' and 'content' keys."
        },
        {
          "name": "update_correction_summaries",
          "description": "Updates the correction summaries JSON file with new data.",
          "args": "main_category (str): The main category of the log entries.\nsubcategory (str): The subcategory of the log entries.\nnew_data (dict): The new data to append to the correction summaries.\nThe dictionary should contain the following keys:\n- \"batch\": The batch label.\n- \"original_summary\": The original summary.\n- \"corrected_summary\": The corrected summary.\n- \"correction_timestamp\": The timestamp of the correction.\n- \"start\": The start timestamp of the batch.\n- \"end\": The end timestamp of the batch.",
          "returns": null
        }
      ]
    },
    "coverage": {
      "method_diff": {
        "LogManager": {
          "missing": [],
          "added": [
            "__init__",
            "_safe_read_or_create_json",
            "read_logs",
            "update_logs",
            "append_entry",
            "get_unsummarized_batch",
            "update_correction_summaries"
          ]
        }
      },
      "missing_tests": [],
      "complexity": {
        "LogManager.__init__": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 6,
          "lines": 6,
          "covered_lines": [
            45,
            46,
            47,
            48,
            49,
            50
          ],
          "missing_lines": []
        },
        "LogManager._safe_read_or_create_json": {
          "complexity": 5,
          "coverage": 0.4286,
          "hits": 3,
          "lines": 7,
          "covered_lines": [
            63,
            69,
            70
          ],
          "missing_lines": []
        },
        "LogManager.read_logs": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 1,
          "lines": 1,
          "covered_lines": [
            83
          ],
          "missing_lines": []
        },
        "LogManager.update_logs": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 3,
          "lines": 3,
          "covered_lines": [
            95,
            96,
            97
          ],
          "missing_lines": []
        },
        "LogManager.append_entry": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 2,
          "lines": 2,
          "covered_lines": [
            110,
            126
          ],
          "missing_lines": []
        },
        "LogManager.get_unsummarized_batch": {
          "complexity": 5,
          "coverage": 0.8947,
          "hits": 10,
          "lines": 11,
          "covered_lines": [
            143,
            144,
            145,
            146,
            147,
            148,
            149,
            150,
            151,
            152
          ],
          "missing_lines": []
        },
        "LogManager.update_correction_summaries": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 3,
          "lines": 3,
          "covered_lines": [
            173,
            174,
            177
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "mypy": {
          "errors": [
            "scripts/core/log_manager.py:52: error: Missing type parameters for generic type \"dict\"  [type-arg]",
            "scripts/core/log_manager.py:75: error: Missing type parameters for generic type \"dict\"  [type-arg]",
            "scripts/core/log_manager.py:85: error: Function is missing a type annotation for one or more arguments  [no-untyped-def]",
            "scripts/core/log_manager.py:110: error: Missing type parameters for generic type \"dict\"  [type-arg]",
            "scripts/core/log_manager.py:130: error: Missing type parameters for generic type \"list\"  [type-arg]",
            "scripts/core/log_manager.py:156: error: Missing type parameters for generic type \"dict\"  [type-arg]"
          ]
        },
        "pydocstyle": {
          "functions": {
            "LogManager": [
              {
                "code": "D101",
                "message": "Missing docstring in public class"
              }
            ],
            "_safe_read_or_create_json": [
              {
                "code": "D205",
                "message": "1 blank line required between summary line and description (found 0)"
              }
            ]
          }
        }
      }
    }
  },
  "core/markdown_logger.py": {
    "docstrings": {
      "module_doc": {
        "description": "Markdown Logger Module\n===============================\nThis module provides the MarkdownLogger class, which is responsible\nfor logging entries to Markdown files. It handles the creation and\nupdating of Markdown files in the specified export directory.",
        "args": null,
        "returns": null
      },
      "classes": [
        {
          "name": "MarkdownLogger",
          "description": "A class to log entries to Markdown files.\nThis class manages the logging of entries into Markdown format,\ncreating new files or updating existing ones as necessary.\nAttributes:\nexport_dir (Path): The directory where Markdown files will be saved.",
          "args": null,
          "returns": null
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "description": "Initialize the MarkdownLogger.\nParameters:\nexport_dir (Path): The directory where Markdown files will be saved.",
          "args": null,
          "returns": null
        },
        {
          "name": "log",
          "description": "Log an entry to a Markdown file.\nParameters:\ndate_str (str): The date string to be used as a header.\nmain_category (str): The main category for the log entry.\nsubcategory (str): The subcategory for the log entry.\nentry (str): The content of the log entry.",
          "args": null,
          "returns": "bool: True if logging was successful, False otherwise."
        }
      ]
    },
    "coverage": {
      "method_diff": {
        "MarkdownLogger": {
          "missing": [],
          "added": [
            "__init__",
            "log"
          ]
        }
      },
      "missing_tests": [],
      "complexity": {
        "MarkdownLogger.__init__": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 1,
          "lines": 1,
          "covered_lines": [
            34
          ],
          "missing_lines": []
        },
        "MarkdownLogger.log": {
          "complexity": 5,
          "coverage": 0.8947,
          "hits": 13,
          "lines": 15,
          "covered_lines": [
            49,
            50,
            51,
            52,
            53,
            55,
            56,
            57,
            58,
            60,
            62,
            64,
            65
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "black": {
          "needs_formatting": true
        }
      }
    }
  },
  "core/summary_engine.py": {
    "docstrings": {
      "module_doc": {
        "description": "Summary Engine Module\n===============================\nThis module provides the SummaryEngine class, which is responsible\nfor generating summaries from log entries using AI summarization.\nIt integrates with the log manager and summary tracker to manage\nthe summarization process.",
        "args": null,
        "returns": null
      },
      "classes": [
        {
          "name": "SummaryEngine",
          "description": "A class to manage the summarization of log entries.\nThis class utilizes an AI summarizer to generate summaries from\nbatches of log entries, coordinating with the log manager and\nsummary tracker.\nAttributes:\nsummarizer (AISummarizer): The AI summarizer instance.\nlog_manager (LogManager): The log manager instance.\ntracker (SummaryTracker): The summary tracker instance.\ntimestamp_format (str): The format for timestamps.\ncontent_key (str): The key for content in log entries.\ntimestamp_key (str): The key for timestamps in log entries.\nbatch_size (int): The number of entries to process in a batch.",
          "args": null,
          "returns": null
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "description": "Initialize the SummaryEngine.\nParameters:\nsummarizer (AISummarizer): The AI summarizer instance.\nlog_manager (LogManager): The log manager instance.\nsummary_tracker (SummaryTracker): The summary tracker instance.\ntimestamp_format (str): The format for timestamps.\ncontent_key (str): The key for content in log entries.\ntimestamp_key (str): The key for timestamps in log entries.\nbatch_size (int): The number of entries to process in a batch.",
          "args": null,
          "returns": null
        },
        {
          "name": "_get_summary",
          "description": "Generate a summary from a batch of log entries.\nParameters:\nbatch_entries (List[Dict[str, Any]]): The batch of log entries.\nsubcategory (str): The subcategory for the summary.",
          "args": null,
          "returns": "Optional[str]: The generated summary, or None if summarization fails."
        },
        {
          "name": "summarize",
          "description": "Summarize log entries for a given main category and subcategory.\nParameters:\nmain_category (str): The main category for the summary.\nsubcategory (str): The subcategory for the summary.",
          "args": null,
          "returns": "bool: True if summarization is successful, False otherwise."
        }
      ]
    },
    "coverage": {
      "method_diff": {
        "SummaryEngine": {
          "missing": [],
          "added": [
            "__init__",
            "_get_summary",
            "summarize"
          ]
        }
      },
      "missing_tests": [],
      "complexity": {
        "SummaryEngine.__init__": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 7,
          "lines": 7,
          "covered_lines": [
            60,
            61,
            62,
            63,
            64,
            65,
            66
          ],
          "missing_lines": []
        },
        "SummaryEngine._get_summary": {
          "complexity": 8,
          "coverage": 0.7778,
          "hits": 7,
          "lines": 9,
          "covered_lines": [
            79,
            80,
            81,
            82,
            83,
            84,
            85,
            89
          ],
          "missing_lines": []
        },
        "SummaryEngine.summarize": {
          "complexity": 5,
          "coverage": 0.8824,
          "hits": 15,
          "lines": 17,
          "covered_lines": [
            102,
            103,
            107,
            111,
            112,
            116,
            117,
            118,
            120,
            129,
            130,
            131,
            132,
            133,
            134,
            135,
            136
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "black": {
          "needs_formatting": true
        }
      }
    }
  },
  "core/summary_tracker.py": {
    "docstrings": {
      "module_doc": {
        "description": "summary_tracker.py\nThis module provides the SummaryTracker class for managing and tracking summaries of logs.\nIt includes functionality for loading tracker data, initializing indexers, and maintaining\nthe state of summaries. This module is essential for the Zephyrus Logger application to\nmanage summaries effectively.\nDependencies:\n- json\n- logging\n- pathlib\n- collections (defaultdict)\n- scripts.indexers.summary_indexer\n- scripts.indexers.raw_log_indexer\n- scripts.utils.file_utils\n- scripts.paths.ZephyrusPaths",
        "args": null,
        "returns": null
      },
      "classes": [
        {
          "name": "SummaryTracker",
          "description": "SummaryTracker manages the loading, initialization, and tracking of summary data for logs.\nAttributes:\npaths (ZephyrusPaths): The paths configuration for the summary tracker.\ntracker_path (Path): The path to the summary tracker file.\ntracker (Dict[str, Dict[str, Any]]): The loaded tracker data.\nsummary_indexer (Optional[SummaryIndexer]): The indexer for summaries.\nraw_indexer (Optional[RawLogIndexer]): The indexer for raw logs.",
          "args": null,
          "returns": null
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "description": "Initializes the SummaryTracker with the given paths.",
          "args": "paths (ZephyrusPaths): The paths configuration for the summary tracker.",
          "returns": null
        },
        {
          "name": "_safe_load_tracker",
          "description": "Safely loads the tracker data from the tracker file.",
          "args": null,
          "returns": "Dict[str, Dict[str, Any]]: The loaded tracker data, or an empty dictionary if loading fails."
        },
        {
          "name": "_safe_init_summary_indexer",
          "description": "Safely initializes the SummaryIndexer.",
          "args": null,
          "returns": "Optional[SummaryIndexer]: The initialized SummaryIndexer, or None if initialization fails."
        },
        {
          "name": "_safe_init_raw_indexer",
          "description": "Safely initializes the RawLogIndexer.",
          "args": null,
          "returns": "Optional[RawLogIndexer]: The initialized RawLogIndexer, or None if initialization fails."
        },
        {
          "name": "get_summarized_count",
          "description": "Retrieves the summarized count for the given main category and subcategory.",
          "args": "main_category (str): The main category.\nsubcategory (str): The subcategory.",
          "returns": "int: The summarized count."
        },
        {
          "name": "update",
          "description": "Updates the tracker with the given summarized and new entries counts.",
          "args": "main_category (str): The main category.\nsubcategory (str): The subcategory.\nsummarized (int, optional): The summarized count. Defaults to 0.\nnew_entries (int, optional): The new entries count. Defaults to 0.",
          "returns": null
        },
        {
          "name": "_save",
          "description": "Saves the tracker data to the tracker file.",
          "args": null,
          "returns": null
        },
        {
          "name": "rebuild",
          "description": "Rebuilds the tracker by clearing the current data and re-counting the logged and summarized entries.",
          "args": null,
          "returns": null
        },
        {
          "name": "validate",
          "description": "Validates the tracker by comparing the summarized counts with the actual counts in the correction summaries.",
          "args": "verbose (bool, optional): If True, logs every subcategory status. Otherwise, only logs mismatches. Defaults to False.",
          "returns": "bool: True if the tracker is valid (no mismatches), False otherwise."
        },
        {
          "name": "get_coverage_data",
          "description": "Returns a structured list of coverage data for all tracked (main, sub) categories.\nEach entry includes:\n- main_category\n- subcategory\n- logged_total\n- estimated_summarized_entries\n- coverage_percent (0100)",
          "args": null,
          "returns": null
        }
      ]
    },
    "coverage": {
      "method_diff": {
        "SummaryTracker": {
          "missing": [],
          "added": [
            "__init__",
            "_safe_load_tracker",
            "_safe_init_summary_indexer",
            "_safe_init_raw_indexer",
            "get_summarized_count",
            "update",
            "_save",
            "rebuild",
            "validate",
            "get_coverage_data"
          ]
        }
      },
      "missing_tests": [],
      "complexity": {
        "SummaryTracker.__init__": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 5,
          "lines": 5,
          "covered_lines": [
            51,
            52,
            53,
            54,
            55
          ],
          "missing_lines": []
        },
        "SummaryTracker._safe_load_tracker": {
          "complexity": 5,
          "coverage": 0.8,
          "hits": 4,
          "lines": 5,
          "covered_lines": [
            64,
            65,
            66,
            68,
            71
          ],
          "missing_lines": []
        },
        "SummaryTracker._safe_init_summary_indexer": {
          "complexity": 3,
          "coverage": 0.5,
          "hits": 2,
          "lines": 4,
          "covered_lines": [
            80,
            81
          ],
          "missing_lines": []
        },
        "SummaryTracker._safe_init_raw_indexer": {
          "complexity": 3,
          "coverage": 0.5,
          "hits": 2,
          "lines": 4,
          "covered_lines": [
            93,
            94
          ],
          "missing_lines": []
        },
        "SummaryTracker.get_summarized_count": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 1,
          "lines": 1,
          "covered_lines": [
            110
          ],
          "missing_lines": []
        },
        "SummaryTracker.update": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 4,
          "lines": 4,
          "covered_lines": [
            124,
            127,
            130,
            131,
            132
          ],
          "missing_lines": []
        },
        "SummaryTracker._save": {
          "complexity": 3,
          "coverage": 0.6667,
          "hits": 2,
          "lines": 3,
          "covered_lines": [
            138,
            139
          ],
          "missing_lines": []
        },
        "SummaryTracker.rebuild": {
          "complexity": 14,
          "coverage": 0.9333,
          "hits": 21,
          "lines": 21,
          "covered_lines": [
            147,
            149,
            150,
            153,
            154,
            155,
            156,
            159,
            162,
            163,
            164,
            165,
            166,
            167,
            169,
            170,
            171,
            173,
            174,
            175,
            176
          ],
          "missing_lines": []
        },
        "SummaryTracker.validate": {
          "complexity": 13,
          "coverage": 0.8261,
          "hits": 13,
          "lines": 17,
          "covered_lines": [
            188,
            192,
            193,
            194,
            196,
            197,
            198,
            199,
            204,
            206,
            215,
            220,
            221,
            225
          ],
          "missing_lines": []
        },
        "SummaryTracker.get_coverage_data": {
          "complexity": 3,
          "coverage": 0.0,
          "hits": 0,
          "lines": 12,
          "covered_lines": [],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "mypy": {
          "errors": [
            "scripts/core/summary_tracker.py:110: error: Returning Any from function declared to return \"int\"  [no-any-return]",
            "scripts/core/summary_tracker.py:231: error: Missing type parameters for generic type \"dict\"  [type-arg]"
          ]
        },
        "pydocstyle": {
          "functions": {
            "_save": [
              {
                "code": "D200",
                "message": "One-line docstring should fit on one line with quotes (found 3)"
              }
            ],
            "rebuild": [
              {
                "code": "D200",
                "message": "One-line docstring should fit on one line with quotes (found 3)"
              }
            ]
          }
        }
      }
    }
  },
  "dashboard/__init__.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": []
    },
    "coverage": {},
    "linting": {}
  },
  "dashboard/app.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "is_excluded",
          "description": null,
          "args": null,
          "returns": null
        },
        {
          "name": "load_artifact",
          "description": "Load either the original JSON file or its compressed twin.\nReturns an **identical** Python structure in both cases.",
          "args": null,
          "returns": null
        },
        {
          "name": "compute_severity",
          "description": "Compute severity metrics for a file based on its linting errors, mypy errors,\ncode complexity, and test coverage.",
          "args": "file_path: Path to the file being analyzed\ncontent: Dictionary containing analysis data for the file",
          "returns": "Dictionary with severity metrics"
        },
        {
          "name": "weighted_coverage",
          "description": "Return overall coverage weighted by each functions lines-of-code.\nExpects every func entry to have keys:\n- \"coverage\"  in [0, 1]\n- \"loc\"       number of source lines (fallback = 1)",
          "args": null,
          "returns": null
        }
      ]
    },
    "coverage": {},
    "linting": {}
  },
  "dev_commit.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "get_current_branch",
          "description": "Returns the name of the current Git branch.",
          "args": null,
          "returns": "str: The current branch name."
        },
        {
          "name": "get_modified_files",
          "description": "Returns a list of files modified (but not yet committed) in the current Git working directory.",
          "args": null,
          "returns": "list[str]: List of modified file paths."
        },
        {
          "name": "is_valid_branch_name",
          "description": "Checks if the provided branch name is valid according to Git naming conventions.",
          "args": "name (str): The branch name to validate.",
          "returns": "bool: True if the branch name is valid, False otherwise."
        },
        {
          "name": "generate_suggested_branch_name",
          "description": "Generates a suggested branch name based on modified files and the current date.",
          "args": null,
          "returns": "str: A suggested branch name in the format 'fix/<keywords>-<date>'."
        },
        {
          "name": "switch_to_new_branch",
          "description": "Prompts the user to create and switch to a new Git branch.\nSuggests a branch name based on modified files and validates user input.\nExits the script if the branch name is invalid or if Git fails to create or push the branch.",
          "args": null,
          "returns": null
        }
      ]
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {
        "get_current_branch": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 2,
          "lines": 2,
          "covered_lines": [
            19,
            26
          ],
          "missing_lines": []
        },
        "get_modified_files": {
          "complexity": 3,
          "coverage": 1.0,
          "hits": 5,
          "lines": 5,
          "covered_lines": [
            36,
            37,
            40,
            41,
            42
          ],
          "missing_lines": []
        },
        "is_valid_branch_name": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 1,
          "lines": 1,
          "covered_lines": [
            55
          ],
          "missing_lines": []
        },
        "generate_suggested_branch_name": {
          "complexity": 4,
          "coverage": 1.0,
          "hits": 11,
          "lines": 11,
          "covered_lines": [
            65,
            66,
            68,
            69,
            70,
            71,
            73,
            75,
            76,
            77,
            78
          ],
          "missing_lines": []
        },
        "switch_to_new_branch": {
          "complexity": 7,
          "coverage": 0.875,
          "hits": 19,
          "lines": 22,
          "covered_lines": [
            87,
            88,
            93,
            94,
            95,
            97,
            98,
            101,
            102,
            104,
            105,
            106,
            107,
            110,
            111,
            112,
            113,
            114,
            115
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "pydocstyle": {
          "functions": {
            "switch_to_new_branch": [
              {
                "code": "D205",
                "message": "1 blank line required between summary line and description (found 0)"
              }
            ]
          }
        }
      }
    }
  },
  "gui/__init__.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": []
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {}
    },
    "linting": {
      "quality": {
        "coverage": {
          "percent": 100.0
        }
      }
    }
  },
  "gui/app.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [
        {
          "name": "ZephyrusLoggerApp",
          "description": "Core Application Class that initializes the main window,\nsets up the style manager, creates the main notebook, and\nintegrates the concrete tabs.",
          "args": null,
          "returns": null
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "description": null,
          "args": null,
          "returns": null
        },
        {
          "name": "_create_status_bar",
          "description": "Creates a basic status bar at the bottom of the main window.",
          "args": null,
          "returns": null
        },
        {
          "name": "run",
          "description": "Starts the main event loop.",
          "args": null,
          "returns": null
        }
      ]
    },
    "coverage": {
      "method_diff": {
        "ZephyrusLoggerApp": {
          "missing": [],
          "added": [
            "__init__",
            "_create_status_bar",
            "run"
          ]
        }
      },
      "missing_tests": [],
      "complexity": {
        "ZephyrusLoggerApp.__init__": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 26,
          "covered_lines": [],
          "missing_lines": [
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41
          ]
        },
        "ZephyrusLoggerApp._create_status_bar": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 9,
          "covered_lines": [],
          "missing_lines": [
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51
          ]
        },
        "ZephyrusLoggerApp.run": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 3,
          "covered_lines": [],
          "missing_lines": [
            53,
            54,
            55
          ]
        }
      }
    },
    "linting": {
      "quality": {
        "mypy": {
          "errors": [
            "scripts/gui/app.py:16: error: Function is missing a type annotation  [no-untyped-def]",
            "scripts/gui/app.py:41: error: Call to untyped function \"_create_status_bar\" in typed context  [no-untyped-call]",
            "scripts/gui/app.py:43: error: Function is missing a return type annotation  [no-untyped-def]",
            "scripts/gui/app.py:53: error: Function is missing a return type annotation  [no-untyped-def]",
            "scripts/gui/app.py:61: error: Call to untyped function \"ZephyrusLoggerApp\" in typed context  [no-untyped-call]",
            "scripts/gui/app.py:62: error: Call to untyped function \"run\" in typed context  [no-untyped-call]"
          ]
        },
        "pydocstyle": {
          "functions": {
            "ZephyrusLoggerApp": [
              {
                "code": "D205",
                "message": "1 blank line required between summary line and description (found 0)"
              }
            ],
            "__init__": [
              {
                "code": "D107",
                "message": "Missing docstring in __init__"
              }
            ]
          }
        }
      }
    }
  },
  "gui/base/__init__.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": []
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {}
    },
    "linting": {
      "quality": {
        "coverage": {
          "percent": 100.0
        }
      }
    }
  },
  "gui/base/base_panel.py": {
    "docstrings": {
      "module_doc": {
        "description": "base_panel.py\nThis module defines the BasePanel class, which provides common functionality for all UI panels.\nCore features include:\n- Providing a base class for panels with consistent styling.\n- Allowing subclasses to implement specific UI components and refresh logic.",
        "args": null,
        "returns": null
      },
      "classes": [
        {
          "name": "BasePanel",
          "description": "BasePanel provides common functionality for all UI panels.\nInherits from ttk.Frame to leverage consistent styling.\nAttributes:\ncontroller (Optional[object]): The controller for handling panel actions.",
          "args": null,
          "returns": null
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "description": "Initializes the BasePanel with the specified parent and controller.",
          "args": "parent (tk.Widget): The parent widget for this panel.\ncontroller (Optional[object]): The controller for handling panel actions. Defaults to None.",
          "returns": null
        },
        {
          "name": "initialize_ui",
          "description": "Set up UI components for the panel.\nOverride this method in subclasses to build specific panel content.",
          "args": null,
          "returns": "None"
        },
        {
          "name": "refresh",
          "description": "Refresh the panel content.\nOverride this method in subclasses if needed.",
          "args": null,
          "returns": "None"
        }
      ]
    },
    "coverage": {
      "method_diff": {
        "BasePanel": {
          "missing": [],
          "added": [
            "__init__",
            "initialize_ui",
            "refresh"
          ]
        }
      },
      "missing_tests": [],
      "complexity": {
        "BasePanel.__init__": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 3,
          "lines": 3,
          "covered_lines": [
            33,
            34,
            35
          ],
          "missing_lines": []
        },
        "BasePanel.initialize_ui": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 0,
          "lines": 0,
          "covered_lines": [],
          "missing_lines": []
        },
        "BasePanel.refresh": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 0,
          "lines": 0,
          "covered_lines": [],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "mypy": {
          "errors": [
            "scripts/gui/base/base_panel.py:25: error: Function is missing a type annotation for one or more arguments  [no-untyped-def]"
          ]
        },
        "pydocstyle": {
          "functions": {
            "BasePanel": [
              {
                "code": "D205",
                "message": "1 blank line required between summary line and description (found 0)"
              }
            ],
            "initialize_ui": [
              {
                "code": "D205",
                "message": "1 blank line required between summary line and description (found 0)"
              }
            ],
            "refresh": [
              {
                "code": "D205",
                "message": "1 blank line required between summary line and description (found 0)"
              }
            ]
          }
        }
      }
    }
  },
  "gui/base/base_tab.py": {
    "docstrings": {
      "module_doc": {
        "description": "base_tab.py\nThis module defines the BaseTab class, which provides a common structure for major tabs in the application.\nCore features include:\n- Providing a base class for tabs with consistent styling.\n- Allowing subclasses to implement specific tab components and behavior.",
        "args": null,
        "returns": null
      },
      "classes": [
        {
          "name": "BaseTab",
          "description": "BaseTab provides a common structure for major tabs in the application.\nInherits from ttk.Frame for consistent styling.\nAttributes:\ncontroller (Optional[object]): The controller for handling tab actions.",
          "args": null,
          "returns": null
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "description": "Initializes the BaseTab with the specified parent and controller.",
          "args": "parent (tk.Widget): The parent widget for this tab.\ncontroller (Optional[object]): The controller for handling tab actions. Defaults to None.",
          "returns": null
        },
        {
          "name": "setup_tab",
          "description": "Set up the tab contents.\nOverride this method in subclasses to build tab-specific components.",
          "args": null,
          "returns": "None"
        },
        {
          "name": "on_show",
          "description": "Called when the tab becomes active.\nOverride to update or refresh content when the tab is shown.",
          "args": null,
          "returns": "None"
        }
      ]
    },
    "coverage": {
      "method_diff": {
        "BaseTab": {
          "missing": [],
          "added": [
            "__init__",
            "setup_tab",
            "on_show"
          ]
        }
      },
      "missing_tests": [],
      "complexity": {
        "BaseTab.__init__": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 3,
          "lines": 3,
          "covered_lines": [
            33,
            34,
            35
          ],
          "missing_lines": []
        },
        "BaseTab.setup_tab": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 0,
          "lines": 0,
          "covered_lines": [],
          "missing_lines": []
        },
        "BaseTab.on_show": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 0,
          "lines": 0,
          "covered_lines": [],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "mypy": {
          "errors": [
            "scripts/gui/base/base_tab.py:25: error: Function is missing a type annotation for one or more arguments  [no-untyped-def]"
          ]
        },
        "pydocstyle": {
          "functions": {
            "BaseTab": [
              {
                "code": "D205",
                "message": "1 blank line required between summary line and description (found 0)"
              }
            ],
            "setup_tab": [
              {
                "code": "D205",
                "message": "1 blank line required between summary line and description (found 0)"
              }
            ],
            "on_show": [
              {
                "code": "D205",
                "message": "1 blank line required between summary line and description (found 0)"
              }
            ]
          }
        }
      }
    }
  },
  "gui/gui.py": {
    "docstrings": {
      "module_doc": {
        "description": "gui.py\nThis module provides the ZephyrusLoggerGUI class, which implements a graphical user interface\nfor the Zephyrus Ideas Logger application using the tkinter library. It manages the GUI components,\nuser interactions, and integrates logging functionality.",
        "args": null,
        "returns": null
      },
      "classes": [
        {
          "name": "ZephyrusLoggerGUI",
          "description": "A class to represent the Zephyrus Ideas Logger GUI.\nThis class initializes the GUI components and handles user interactions.\nAttributes:\ncontroller (GUIController): The controller for managing the application's logic.\nlogger (logging.Logger): Logger for tracking GUI events and actions.\nconfig (dict): Configuration settings loaded from the config file.\ncategory_structure (dict): Structure of categories for the GUI.\nroot (tk.Tk): The main window of the GUI application.",
          "args": null,
          "returns": null
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "description": "Initialize the ZephyrusLoggerGUI.",
          "args": "controller (GUIController): The controller for managing the application's logic.",
          "returns": null
        },
        {
          "name": "_setup_gui_logging",
          "description": "Set up the logging for the GUI.\nThis method configures the logging handler to display logs in the GUI.",
          "args": null,
          "returns": null
        },
        {
          "name": "_build_widgets",
          "description": "Build the GUI widgets and layout.\nThis method creates and arranges the GUI components, such as frames and buttons.",
          "args": null,
          "returns": null
        },
        {
          "name": "_update_coverage_display",
          "description": "Update the coverage display.\nThis method retrieves the coverage data from the controller and updates the coverage display.",
          "args": null,
          "returns": null
        },
        {
          "name": "_populate_category_dropdown",
          "description": "Populate the category dropdown menu.\nThis method retrieves the categories from the controller and populates the dropdown menu.",
          "args": null,
          "returns": null
        },
        {
          "name": "_update_main_category",
          "description": "Update the main category.\nThis method updates the main category and subcategory dropdown menus.",
          "args": "new_main (str): The new main category.",
          "returns": null
        },
        {
          "name": "_log_entry",
          "description": "Log a new entry.\nThis method logs a new entry based on the user's input.",
          "args": null,
          "returns": null
        },
        {
          "name": "_manual_summarize",
          "description": "Manually summarize the logs.\nThis method generates a summary of the logs based on the user's input.",
          "args": null,
          "returns": null
        },
        {
          "name": "_search_summary",
          "description": "Search for summaries.\nThis method searches for summaries based on the user's input.",
          "args": null,
          "returns": null
        },
        {
          "name": "_search_raw",
          "description": "Search for raw logs.\nThis method searches for raw logs based on the user's input.",
          "args": null,
          "returns": null
        },
        {
          "name": "_rebuild_tracker",
          "description": "Rebuild the tracker.\nThis method rebuilds the tracker based on the user's input.",
          "args": null,
          "returns": null
        },
        {
          "name": "_show_coverage",
          "description": "Show the coverage.\nThis method displays the coverage data.",
          "args": null,
          "returns": null
        },
        {
          "name": "run",
          "description": "Run the GUI application.\nThis method starts the GUI event loop.",
          "args": null,
          "returns": null
        }
      ]
    },
    "coverage": {
      "method_diff": {
        "ZephyrusLoggerGUI": {
          "missing": [],
          "added": [
            "__init__",
            "_setup_gui_logging",
            "_build_widgets",
            "_update_coverage_display",
            "_populate_category_dropdown",
            "_update_main_category",
            "_log_entry",
            "_manual_summarize",
            "_search_summary",
            "_search_raw",
            "_rebuild_tracker",
            "_show_coverage",
            "run"
          ]
        }
      },
      "missing_tests": [],
      "complexity": {
        "ZephyrusLoggerGUI.__init__": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 21,
          "covered_lines": [],
          "missing_lines": [
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53
          ]
        },
        "ZephyrusLoggerGUI._setup_gui_logging": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 11,
          "covered_lines": [],
          "missing_lines": [
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65
          ]
        },
        "ZephyrusLoggerGUI._build_widgets": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 83,
          "covered_lines": [],
          "missing_lines": [
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            82,
            83,
            84,
            85,
            86,
            87,
            88,
            89,
            90,
            91,
            92,
            93,
            94,
            95,
            96,
            97,
            98,
            99,
            100,
            101,
            102,
            103,
            104,
            105,
            106,
            107,
            108,
            109,
            110,
            111,
            112,
            113,
            114,
            115,
            116,
            117,
            118,
            119,
            120,
            121,
            122,
            123,
            124,
            125,
            126,
            127,
            128,
            129,
            130,
            131,
            132,
            133,
            134,
            135,
            136,
            137,
            138,
            139,
            140,
            141,
            142,
            143,
            144,
            145,
            146,
            147,
            148,
            149
          ]
        },
        "ZephyrusLoggerGUI._update_coverage_display": {
          "complexity": 5,
          "coverage": 0.0,
          "hits": 0,
          "lines": 26,
          "covered_lines": [],
          "missing_lines": [
            151,
            152,
            153,
            154,
            155,
            156,
            157,
            158,
            159,
            160,
            161,
            162,
            163,
            164,
            165,
            166,
            167,
            168,
            169,
            170,
            171,
            172,
            173,
            174,
            175,
            176
          ]
        },
        "ZephyrusLoggerGUI._populate_category_dropdown": {
          "complexity": 2,
          "coverage": 0.0,
          "hits": 0,
          "lines": 14,
          "covered_lines": [],
          "missing_lines": [
            178,
            179,
            180,
            181,
            182,
            183,
            184,
            185,
            186,
            187,
            188,
            189,
            190,
            191
          ]
        },
        "ZephyrusLoggerGUI._update_main_category": {
          "complexity": 2,
          "coverage": 0.0,
          "hits": 0,
          "lines": 17,
          "covered_lines": [],
          "missing_lines": [
            193,
            194,
            195,
            196,
            197,
            198,
            199,
            200,
            201,
            202,
            203,
            204,
            205,
            206,
            207,
            208,
            209
          ]
        },
        "ZephyrusLoggerGUI._log_entry": {
          "complexity": 4,
          "coverage": 0.0,
          "hits": 0,
          "lines": 19,
          "covered_lines": [],
          "missing_lines": [
            211,
            212,
            213,
            214,
            215,
            216,
            217,
            218,
            219,
            220,
            221,
            222,
            223,
            224,
            225,
            226,
            227,
            228,
            229
          ]
        },
        "ZephyrusLoggerGUI._manual_summarize": {
          "complexity": 3,
          "coverage": 0.0,
          "hits": 0,
          "lines": 14,
          "covered_lines": [],
          "missing_lines": [
            231,
            232,
            233,
            234,
            235,
            236,
            237,
            238,
            239,
            240,
            241,
            242,
            243,
            244
          ]
        },
        "ZephyrusLoggerGUI._search_summary": {
          "complexity": 5,
          "coverage": 0.0,
          "hits": 0,
          "lines": 17,
          "covered_lines": [],
          "missing_lines": [
            246,
            247,
            248,
            249,
            250,
            251,
            252,
            253,
            254,
            255,
            256,
            257,
            258,
            259,
            260,
            261,
            262
          ]
        },
        "ZephyrusLoggerGUI._search_raw": {
          "complexity": 5,
          "coverage": 0.0,
          "hits": 0,
          "lines": 17,
          "covered_lines": [],
          "missing_lines": [
            264,
            265,
            266,
            267,
            268,
            269,
            270,
            271,
            272,
            273,
            274,
            275,
            276,
            277,
            278,
            279,
            280
          ]
        },
        "ZephyrusLoggerGUI._rebuild_tracker": {
          "complexity": 3,
          "coverage": 0.0,
          "hits": 0,
          "lines": 20,
          "covered_lines": [],
          "missing_lines": [
            282,
            283,
            284,
            285,
            286,
            287,
            288,
            289,
            290,
            291,
            292,
            293,
            294,
            295,
            296,
            297,
            298,
            299,
            300,
            301
          ]
        },
        "ZephyrusLoggerGUI._show_coverage": {
          "complexity": 3,
          "coverage": 0.0,
          "hits": 0,
          "lines": 12,
          "covered_lines": [],
          "missing_lines": [
            303,
            304,
            305,
            306,
            307,
            308,
            309,
            310,
            311,
            312,
            313,
            314
          ]
        },
        "ZephyrusLoggerGUI.run": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 7,
          "covered_lines": [],
          "missing_lines": [
            316,
            317,
            318,
            319,
            320,
            321,
            322
          ]
        }
      }
    },
    "linting": {
      "quality": {
        "coverage": {
          "percent": 13.4
        }
      }
    }
  },
  "gui/gui_controller.py": {
    "docstrings": {
      "module_doc": {
        "description": "gui_controller.py\nThis module provides the GUIController class for managing the interaction between the GUI\nand the logging core of the Zephyrus Logger application. It handles the initialization of\nthe logger core and facilitates logging entries through the GUI.\nDependencies:\n- os\n- logging\n- scripts.core.core.ZephyrusLoggerCore",
        "args": null,
        "returns": null
      },
      "classes": [
        {
          "name": "GUIController",
          "description": "GUIController manages the interaction between the GUI and the logging core.\nAttributes:\ncore (ZephyrusLoggerCore): The instance of the ZephyrusLoggerCore used for logging.",
          "args": null,
          "returns": null
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "description": "Initializes the GUIController with the given logger core or initializes a new one.",
          "args": "logger_core (Optional[ZephyrusLoggerCore]): The logger core instance. If None, a new instance will be created.\nscript_dir (Optional[str]): The directory of the script. Defaults to the current working directory.",
          "returns": null
        },
        {
          "name": "log_entry",
          "description": "Logs an entry with the specified main category, subcategory, and text.",
          "args": "main (str): The main category of the log entry.\nsub (str): The subcategory of the log entry.\ntext (str): The text content of the log entry.",
          "returns": "Any: The result of the logging operation."
        },
        {
          "name": "force_summarize_all",
          "description": "Forces the summarization of all logs.",
          "args": null,
          "returns": "Any: The result of the summarization operation."
        },
        {
          "name": "search_summaries",
          "description": "Searches for summaries matching the given query.",
          "args": "query (str): The search query.",
          "returns": "Any: The result of the search operation."
        },
        {
          "name": "search_raw_logs",
          "description": "Searches for raw logs matching the given query.",
          "args": "query (str): The search query.",
          "returns": "Any: The result of the search operation."
        },
        {
          "name": "rebuild_tracker",
          "description": "Rebuilds the summary tracker and returns True if successful, False otherwise.",
          "args": null,
          "returns": null
        },
        {
          "name": "get_tracker_status",
          "description": "Returns a user-friendly status string of the summary tracker.",
          "args": null,
          "returns": null
        },
        {
          "name": "get_coverage_data",
          "description": "Retrieves coverage data from the tracker for the UI heatmap.",
          "args": null,
          "returns": null
        },
        {
          "name": "get_logs",
          "description": "Retrieves the contents of the plain text log file as a string.",
          "args": null,
          "returns": null
        }
      ]
    },
    "coverage": {
      "method_diff": {
        "GUIController": {
          "missing": [],
          "added": [
            "__init__",
            "log_entry",
            "force_summarize_all",
            "search_summaries",
            "search_raw_logs",
            "rebuild_tracker",
            "get_tracker_status",
            "get_coverage_data",
            "get_logs"
          ]
        }
      },
      "missing_tests": [],
      "complexity": {
        "GUIController.__init__": {
          "complexity": 5,
          "coverage": 0.0,
          "hits": 0,
          "lines": 19,
          "covered_lines": [],
          "missing_lines": [
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48
          ]
        },
        "GUIController.log_entry": {
          "complexity": 3,
          "coverage": 0.0,
          "hits": 0,
          "lines": 16,
          "covered_lines": [],
          "missing_lines": [
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65
          ]
        },
        "GUIController.force_summarize_all": {
          "complexity": 3,
          "coverage": 0.0,
          "hits": 0,
          "lines": 11,
          "covered_lines": [],
          "missing_lines": [
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74,
            75,
            76,
            77
          ]
        },
        "GUIController.search_summaries": {
          "complexity": 3,
          "coverage": 0.0,
          "hits": 0,
          "lines": 14,
          "covered_lines": [],
          "missing_lines": [
            79,
            80,
            81,
            82,
            83,
            84,
            85,
            86,
            87,
            88,
            89,
            90,
            91,
            92
          ]
        },
        "GUIController.search_raw_logs": {
          "complexity": 3,
          "coverage": 0.0,
          "hits": 0,
          "lines": 14,
          "covered_lines": [],
          "missing_lines": [
            94,
            95,
            96,
            97,
            98,
            99,
            100,
            101,
            102,
            103,
            104,
            105,
            106,
            107
          ]
        },
        "GUIController.rebuild_tracker": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 7,
          "covered_lines": [],
          "missing_lines": [
            109,
            110,
            111,
            112,
            113,
            114,
            115
          ]
        },
        "GUIController.get_tracker_status": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 6,
          "covered_lines": [],
          "missing_lines": [
            117,
            118,
            119,
            120,
            121,
            122
          ]
        },
        "GUIController.get_coverage_data": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 5,
          "covered_lines": [],
          "missing_lines": [
            124,
            125,
            126,
            127,
            128
          ]
        },
        "GUIController.get_logs": {
          "complexity": 4,
          "coverage": 0.0,
          "hits": 0,
          "lines": 10,
          "covered_lines": [],
          "missing_lines": [
            130,
            131,
            132,
            133,
            134,
            135,
            136,
            137,
            138,
            139
          ]
        }
      }
    },
    "linting": {
      "quality": {
        "mypy": {
          "errors": [
            "scripts/gui/gui_controller.py:75: error: \"ZephyrusLoggerCore\" has no attribute \"force_summary_all\"  [attr-defined]"
          ]
        },
        "pydocstyle": {
          "functions": {
            "rebuild_tracker": [
              {
                "code": "D200",
                "message": "One-line docstring should fit on one line with quotes (found 3)"
              }
            ],
            "get_tracker_status": [
              {
                "code": "D200",
                "message": "One-line docstring should fit on one line with quotes (found 3)"
              }
            ],
            "get_coverage_data": [
              {
                "code": "D200",
                "message": "One-line docstring should fit on one line with quotes (found 3)"
              }
            ],
            "get_logs": [
              {
                "code": "D200",
                "message": "One-line docstring should fit on one line with quotes (found 3)"
              }
            ]
          }
        }
      }
    }
  },
  "gui/gui_helpers.py": {
    "docstrings": {
      "module_doc": {
        "description": "gui_helpers.py\nThis module provides utility functions for building and customizing the\nZephyrus Logger application's graphical user interface (GUI).\nCore features include:\n- Validating user input for logging and searching.\n- Creating and customizing Tkinter widgets (e.g. scrolled text, buttons).\n- Displaying alerts and messages using Tkinter's messagebox module.\n- Utility functions for reading and writing JSON files.\nIntended to provide a set of reusable functions for the GUI components of\nthe Zephyrus Logger application.",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "validate_log_input",
          "description": "Returns False if the input is empty, None, or just whitespace.\nLogs a warning if invalid.",
          "args": null,
          "returns": null
        },
        {
          "name": "get_current_date",
          "description": "Returns the current date as a string in 'YYYY-MM-DD' format.\n:return: Current date as a string.\n:rtype: str",
          "args": null,
          "returns": null
        },
        {
          "name": "get_current_timestamp",
          "description": "Returns the current date and time as a formatted string (YYYY-MM-DD HH:MM:SS).",
          "args": null,
          "returns": null
        },
        {
          "name": "clear_text_input",
          "description": "Clears all text from the given Tkinter text entry widget.",
          "args": "entry_widget: The Tkinter text widget to be cleared.",
          "returns": null
        },
        {
          "name": "update_status_label",
          "description": "Update the text and foreground color of a Tkinter label widget.",
          "args": "label (tk.Label): The label widget to update.\nmessage (str): The text to display on the label.\ncolor (str, optional): The text color. Defaults to \"blue\".",
          "returns": null
        },
        {
          "name": "get_selected_option",
          "description": "Returns the currently selected option from a Tkinter menu variable, or a default value if none is selected.",
          "args": "menu_var: A Tkinter variable associated with a menu widget.\ndefault (str, optional): The value to return if no option is selected. Defaults to \"General\".",
          "returns": "str: The selected option or the default value."
        },
        {
          "name": "append_log_entry",
          "description": "Appends a log entry with a timestamp and content to the specified log file, organizing entries by date, category, and subcategory.",
          "args": "log_file (str): Path to the JSON log file.\ndate (str): Date key for the log entry (YYYY-MM-DD).\ncategory (str): Category under which to store the entry.\nsubcategory (str): Subcategory under the category.\nentry_text (str): The content of the log entry.",
          "returns": null
        },
        {
          "name": "get_category_options",
          "description": "Retrieves a list of category names from a JSON file at the given path.",
          "args": "categories_json_path (str): Path to the JSON file containing categories.",
          "returns": "list: List of category names, or an empty list if reading fails."
        },
        {
          "name": "create_status_label",
          "description": "Create and pack a status label widget in the given root window.",
          "args": "root: The parent Tkinter widget.\nstatus_var: A Tkinter StringVar to display as the label's text.",
          "returns": "The created Label widget."
        },
        {
          "name": "create_log_frame",
          "description": "Creates and returns a disabled scrolled text widget within a frame for logging purposes in a Tkinter GUI.",
          "args": "root: The parent Tkinter widget.",
          "returns": "tuple: (log_text, log_frame) where log_text is the ScrolledText widget and log_frame is the containing Frame."
        },
        {
          "name": "log_message",
          "description": "Appends a timestamped message to the provided Tkinter text widget for logging purposes.",
          "args": "log_text_widget (tkinter.Text): The text widget where the log message will be displayed.\nmessage (str): The message to log.",
          "returns": null
        },
        {
          "name": "create_dropdown_menu",
          "description": "Creates a labeled dropdown menu (OptionMenu) in the given Tkinter frame.",
          "args": "frame: The parent Tkinter frame to place the dropdown menu in.\nlabel_text: The text to display as the label next to the dropdown.\nvariable: A Tkinter variable to store the selected option.\noptions: A list of options to display in the dropdown menu.",
          "returns": "The created Tkinter OptionMenu widget."
        },
        {
          "name": "create_button",
          "description": "Creates and returns a Tkinter Button widget with customizable text, command, size, and colors.",
          "args": "frame: The parent widget where the button will be placed.\ntext (str): The label displayed on the button.\ncommand (callable): The function to be called when the button is clicked.\nwidth (int, optional): The width of the button. Defaults to 15.\nheight (int, optional): The height of the button. Defaults to 2.\nbg (str, optional): The background color of the button. Defaults to \"#4CAF50\".\nfg (str, optional): The text color of the button. Defaults to \"white\".",
          "returns": "tk.Button: The configured Button widget."
        },
        {
          "name": "show_messagebox",
          "description": "Displays a message box with the specified icon, title, and message using tkinter.",
          "args": "icon (str): Type of message box to display ('info', 'warning', or 'error').\ntitle (str): The title of the message box window.\nmessage (str): The message to display in the message box.",
          "returns": null
        },
        {
          "name": "create_text_entry",
          "description": "Creates a text entry widget for user input.",
          "args": "root (tk.Tk or tk.Frame): The parent widget.\nheight (int): Number of lines tall.\nwidth (int): Number of characters wide.",
          "returns": "tk.Text: A configured Text widget."
        },
        {
          "name": "format_summary_results",
          "description": "Formats a list of result items into a readable summary string.\nEach result can be a dict with 'score' and 'text' keys, a tuple/list with score and text,\nor any other type, which will be converted to string with a default score of 0.0.\nHandles exceptions gracefully and includes error information in the output.",
          "args": "results (list): List of result items to format.",
          "returns": "str: Formatted summary string with scores and texts."
        },
        {
          "name": "format_raw_results",
          "description": "Formats a list of raw result items into a readable string.\nEach result is processed based on its type (dict, list/tuple, or other),\nand formatted with a '[RAW LOG MATCH]' prefix. Handles exceptions by\nincluding error details in the output.",
          "args": "results (list): List of raw result items to format.",
          "returns": "str: Formatted string representation of all results."
        },
        {
          "name": "display_message",
          "description": "Displays an informational message box.",
          "args": null,
          "returns": null
        },
        {
          "name": "display_error",
          "description": "Displays an error message box.",
          "args": null,
          "returns": null
        },
        {
          "name": "format_coverage_data",
          "description": "Formats the structured coverage data into a readable string grouped by main category.",
          "args": "data (list[dict]): List of coverage data entries.",
          "returns": "str: A nicely formatted string for displaying coverage stats."
        }
      ]
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {
        "validate_log_input": {
          "complexity": 3,
          "coverage": 0.0,
          "hits": 0,
          "lines": 9,
          "covered_lines": [],
          "missing_lines": [
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35
          ]
        },
        "get_current_date": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 8,
          "covered_lines": [],
          "missing_lines": [
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45
          ]
        },
        "get_current_timestamp": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 5,
          "covered_lines": [],
          "missing_lines": [
            48,
            49,
            50,
            51,
            52
          ]
        },
        "clear_text_input": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 8,
          "covered_lines": [],
          "missing_lines": [
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62
          ]
        },
        "update_status_label": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 10,
          "covered_lines": [],
          "missing_lines": [
            65,
            66,
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74
          ]
        },
        "get_selected_option": {
          "complexity": 2,
          "coverage": 0.0,
          "hits": 0,
          "lines": 12,
          "covered_lines": [],
          "missing_lines": [
            77,
            78,
            79,
            80,
            81,
            82,
            83,
            84,
            85,
            86,
            87,
            88
          ]
        },
        "append_log_entry": {
          "complexity": 4,
          "coverage": 0.0,
          "hits": 0,
          "lines": 25,
          "covered_lines": [],
          "missing_lines": [
            91,
            92,
            93,
            94,
            95,
            96,
            97,
            98,
            99,
            100,
            101,
            102,
            103,
            104,
            105,
            106,
            107,
            108,
            109,
            110,
            111,
            112,
            113,
            114,
            115
          ]
        },
        "get_category_options": {
          "complexity": 3,
          "coverage": 0.0,
          "hits": 0,
          "lines": 15,
          "covered_lines": [],
          "missing_lines": [
            118,
            119,
            120,
            121,
            122,
            123,
            124,
            125,
            126,
            127,
            128,
            129,
            130,
            131,
            132
          ]
        },
        "create_status_label": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 14,
          "covered_lines": [],
          "missing_lines": [
            135,
            136,
            137,
            138,
            139,
            140,
            141,
            142,
            143,
            144,
            145,
            146,
            147,
            148
          ]
        },
        "create_log_frame": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 16,
          "covered_lines": [],
          "missing_lines": [
            151,
            152,
            153,
            154,
            155,
            156,
            157,
            158,
            159,
            160,
            161,
            162,
            163,
            164,
            165,
            166
          ]
        },
        "log_message": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 13,
          "covered_lines": [],
          "missing_lines": [
            169,
            170,
            171,
            172,
            173,
            174,
            175,
            176,
            177,
            178,
            179,
            180,
            181
          ]
        },
        "create_dropdown_menu": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 20,
          "covered_lines": [],
          "missing_lines": [
            184,
            185,
            186,
            187,
            188,
            189,
            190,
            191,
            192,
            193,
            194,
            195,
            196,
            197,
            198,
            199,
            200,
            201,
            202,
            203
          ]
        },
        "create_button": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 25,
          "covered_lines": [],
          "missing_lines": [
            206,
            207,
            208,
            209,
            210,
            211,
            212,
            213,
            214,
            215,
            216,
            217,
            218,
            219,
            220,
            221,
            222,
            223,
            224,
            225,
            226,
            227,
            228,
            229,
            230
          ]
        },
        "show_messagebox": {
          "complexity": 4,
          "coverage": 0.0,
          "hits": 0,
          "lines": 15,
          "covered_lines": [],
          "missing_lines": [
            233,
            234,
            235,
            236,
            237,
            238,
            239,
            240,
            241,
            242,
            243,
            244,
            245,
            246,
            247
          ]
        },
        "create_text_entry": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 15,
          "covered_lines": [],
          "missing_lines": [
            250,
            251,
            252,
            253,
            254,
            255,
            256,
            257,
            258,
            259,
            260,
            261,
            262,
            263,
            264
          ]
        },
        "format_summary_results": {
          "complexity": 7,
          "coverage": 0.0,
          "hits": 0,
          "lines": 28,
          "covered_lines": [],
          "missing_lines": [
            267,
            268,
            269,
            270,
            271,
            272,
            273,
            274,
            275,
            276,
            277,
            278,
            279,
            280,
            281,
            282,
            283,
            284,
            285,
            286,
            287,
            288,
            289,
            290,
            291,
            292,
            293,
            294
          ]
        },
        "format_raw_results": {
          "complexity": 6,
          "coverage": 0.0,
          "hits": 0,
          "lines": 27,
          "covered_lines": [],
          "missing_lines": [
            297,
            298,
            299,
            300,
            301,
            302,
            303,
            304,
            305,
            306,
            307,
            308,
            309,
            310,
            311,
            312,
            313,
            314,
            315,
            316,
            317,
            318,
            319,
            320,
            321,
            322,
            323
          ]
        },
        "display_message": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 5,
          "covered_lines": [],
          "missing_lines": [
            326,
            327,
            328,
            329,
            330
          ]
        },
        "display_error": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 5,
          "covered_lines": [],
          "missing_lines": [
            333,
            334,
            335,
            336,
            337
          ]
        },
        "format_coverage_data": {
          "complexity": 4,
          "coverage": 0.0,
          "hits": 0,
          "lines": 26,
          "covered_lines": [],
          "missing_lines": [
            340,
            341,
            342,
            343,
            344,
            345,
            346,
            347,
            348,
            349,
            350,
            351,
            352,
            353,
            354,
            355,
            356,
            357,
            358,
            359,
            360,
            361,
            362,
            363,
            364,
            365
          ]
        }
      }
    },
    "linting": {
      "quality": {
        "mypy": {
          "errors": [
            "scripts/gui/gui_helpers.py:88: error: Call to untyped function \"get\" in typed context  [no-untyped-call]",
            "scripts/gui/gui_helpers.py:118: error: Missing type parameters for generic type \"list\"  [type-arg]",
            "scripts/gui/gui_helpers.py:151: error: Missing type parameters for generic type \"tuple\"  [type-arg]",
            "scripts/gui/gui_helpers.py:185: error: Missing type parameters for generic type \"list\"  [type-arg]",
            "scripts/gui/gui_helpers.py:201: error: Argument 2 to \"OptionMenu\" has incompatible type \"Variable\"; expected \"StringVar\"  [arg-type]",
            "scripts/gui/gui_helpers.py:209: error: Function \"builtins.callable\" is not valid as a type  [valid-type]",
            "scripts/gui/gui_helpers.py:267: error: Missing type parameters for generic type \"list\"  [type-arg]",
            "scripts/gui/gui_helpers.py:297: error: Missing type parameters for generic type \"list\"  [type-arg]",
            "scripts/gui/gui_helpers.py:340: error: Missing type parameters for generic type \"dict\"  [type-arg]"
          ]
        },
        "pydocstyle": {
          "functions": {
            "validate_log_input": [
              {
                "code": "D205",
                "message": "1 blank line required between summary line and description (found 0)"
              }
            ],
            "get_current_timestamp": [
              {
                "code": "D200",
                "message": "One-line docstring should fit on one line with quotes (found 3)"
              }
            ],
            "display_message": [
              {
                "code": "D200",
                "message": "One-line docstring should fit on one line with quotes (found 3)"
              }
            ],
            "display_error": [
              {
                "code": "D200",
                "message": "One-line docstring should fit on one line with quotes (found 3)"
              }
            ]
          }
        }
      }
    }
  },
  "gui/gui_logging.py": {
    "docstrings": {
      "module_doc": {
        "description": "gui_logging.py\nThis module provides a logging handler that appends log messages to a Tkinter Text widget.",
        "args": null,
        "returns": null
      },
      "classes": [
        {
          "name": "GUILogHandler",
          "description": "A logging handler that appends log messages to a Tkinter Text widget.",
          "args": null,
          "returns": null
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "description": ":param text_widget: The Text widget where log messages should be appended.",
          "args": null,
          "returns": null
        },
        {
          "name": "emit",
          "description": "Emits a log message to the associated Text widget.\n:param record: logging.LogRecord",
          "args": null,
          "returns": null
        },
        {
          "name": "append_message",
          "description": "Appends a log message to the associated Text widget.\nThis method is designed to be called from the main thread,\nand will block until the message is appended.",
          "args": null,
          "returns": null
        }
      ]
    },
    "coverage": {
      "method_diff": {
        "GUILogHandler": {
          "missing": [],
          "added": [
            "__init__",
            "emit",
            "append_message"
          ]
        }
      },
      "missing_tests": [],
      "complexity": {
        "GUILogHandler.__init__": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 6,
          "covered_lines": [],
          "missing_lines": [
            16,
            17,
            18,
            19,
            20,
            21
          ]
        },
        "GUILogHandler.emit": {
          "complexity": 3,
          "coverage": 0.0,
          "hits": 0,
          "lines": 12,
          "covered_lines": [],
          "missing_lines": [
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34
          ]
        },
        "GUILogHandler.append_message": {
          "complexity": 4,
          "coverage": 0.0,
          "hits": 0,
          "lines": 17,
          "covered_lines": [],
          "missing_lines": [
            36,
            37,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52
          ]
        }
      }
    },
    "linting": {
      "quality": {
        "pydocstyle": {
          "functions": {
            "GUILogHandler": [
              {
                "code": "D200",
                "message": "One-line docstring should fit on one line with quotes (found 3)"
              }
            ],
            "__init__": [
              {
                "code": "D200",
                "message": "One-line docstring should fit on one line with quotes (found 3)"
              }
            ]
          }
        }
      }
    }
  },
  "gui/panels/__init__.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": []
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {}
    },
    "linting": {
      "quality": {
        "coverage": {
          "percent": 100.0
        }
      }
    }
  },
  "gui/panels/action_panel.py": {
    "docstrings": {
      "module_doc": {
        "description": "action_panel.py\nThis module defines the ActionPanel class, which hosts buttons for actions such as summarizing or rebuilding.\nCore features include:\n- Creating buttons for summarizing and rebuilding functionality.\n- Integrating with the application controller to trigger actions.",
        "args": null,
        "returns": null
      },
      "classes": [
        {
          "name": "ActionPanel",
          "description": "ActionPanel hosts buttons for actions such as summarizing or rebuilding.\nAttributes:\nframe (Optional[ttk.Frame]): The frame containing the action buttons.\nsummarize_button (Optional[ttk.Button]): The button for summarizing logs.\nrebuild_button (Optional[ttk.Button]): The button for rebuilding the tracker.",
          "args": null,
          "returns": null
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "description": "Initializes the ActionPanel with the specified parent and controller.",
          "args": "parent (tk.Widget): The parent widget for this panel.\ncontroller (Optional[object]): The controller for handling actions. Defaults to None.",
          "returns": null
        },
        {
          "name": "initialize_ui",
          "description": "Creates and packs the action buttons into the panel.",
          "args": null,
          "returns": "None"
        },
        {
          "name": "on_summarize",
          "description": "Trigger the controller's summarize function if available.",
          "args": null,
          "returns": "None"
        },
        {
          "name": "on_rebuild",
          "description": "Trigger the controller's rebuild_tracker function if available.",
          "args": null,
          "returns": "None"
        },
        {
          "name": "refresh",
          "description": "Action panel may not need refreshing, but this hook is here if needed.",
          "args": null,
          "returns": "None"
        }
      ]
    },
    "coverage": {
      "method_diff": {
        "ActionPanel": {
          "missing": [],
          "added": [
            "__init__",
            "initialize_ui",
            "on_summarize",
            "on_rebuild",
            "refresh"
          ]
        }
      },
      "missing_tests": [],
      "complexity": {
        "ActionPanel.__init__": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 4,
          "lines": 4,
          "covered_lines": [
            38,
            39,
            40,
            41
          ],
          "missing_lines": []
        },
        "ActionPanel.initialize_ui": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 6,
          "lines": 6,
          "covered_lines": [
            51,
            52,
            55,
            58,
            61,
            64
          ],
          "missing_lines": []
        },
        "ActionPanel.on_summarize": {
          "complexity": 5,
          "coverage": 0.7778,
          "hits": 6,
          "lines": 7,
          "covered_lines": [
            73,
            74,
            75,
            76,
            77,
            78
          ],
          "missing_lines": []
        },
        "ActionPanel.on_rebuild": {
          "complexity": 5,
          "coverage": 0.7778,
          "hits": 6,
          "lines": 7,
          "covered_lines": [
            89,
            90,
            91,
            92,
            93,
            94
          ],
          "missing_lines": []
        },
        "ActionPanel.refresh": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 0,
          "lines": 0,
          "covered_lines": [],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "mypy": {
          "errors": [
            "scripts/gui/panels/action_panel.py:29: error: Function is missing a type annotation for one or more arguments  [no-untyped-def]"
          ]
        }
      }
    }
  },
  "gui/panels/coverage_panel.py": {
    "docstrings": {
      "module_doc": {
        "description": "coverage_panel.py\nThis module defines the CoveragePanel class, which displays coverage metrics in a tree view.\nCore features include:\n- Displaying coverage metrics for various categories.\n- Integrating with the application controller to fetch coverage data.",
        "args": null,
        "returns": null
      },
      "classes": [
        {
          "name": "CoveragePanel",
          "description": "CoveragePanel displays coverage metrics in a tree view.\nAttributes:\nframe (Optional[ttk.LabelFrame]): The frame containing the coverage metrics.\ntree (Optional[ttk.Treeview]): The tree view for displaying coverage data.",
          "args": null,
          "returns": null
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "description": "Initializes the CoveragePanel with the specified parent and controller.",
          "args": "parent (tk.Widget): The parent widget for this panel.\ncontroller (Optional[object]): The controller for handling coverage data. Defaults to None.",
          "returns": null
        },
        {
          "name": "initialize_ui",
          "description": "Creates and packs the user interface components for the coverage panel.",
          "args": null,
          "returns": "None"
        },
        {
          "name": "refresh",
          "description": "Refreshes the coverage data displayed in the tree view.",
          "args": null,
          "returns": "None"
        }
      ]
    },
    "coverage": {
      "method_diff": {
        "CoveragePanel": {
          "missing": [],
          "added": [
            "__init__",
            "initialize_ui",
            "refresh"
          ]
        }
      },
      "missing_tests": [],
      "complexity": {
        "CoveragePanel.__init__": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 3,
          "lines": 3,
          "covered_lines": [
            36,
            37,
            38
          ],
          "missing_lines": []
        },
        "CoveragePanel.initialize_ui": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 9,
          "lines": 9,
          "covered_lines": [
            48,
            49,
            52,
            53,
            54,
            55,
            56,
            57,
            58
          ],
          "missing_lines": []
        },
        "CoveragePanel.refresh": {
          "complexity": 7,
          "coverage": 0.7778,
          "hits": 10,
          "lines": 12,
          "covered_lines": [
            68,
            72,
            73,
            75,
            77,
            78,
            79,
            80,
            81,
            82
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "mypy": {
          "errors": [
            "scripts/gui/panels/coverage_panel.py:27: error: Function is missing a type annotation for one or more arguments  [no-untyped-def]",
            "scripts/gui/panels/coverage_panel.py:68: error: Item \"None\" of \"Treeview | None\" has no attribute \"get_children\"  [union-attr]",
            "scripts/gui/panels/coverage_panel.py:69: error: Item \"None\" of \"Treeview | None\" has no attribute \"delete\"  [union-attr]",
            "scripts/gui/panels/coverage_panel.py:80: error: Item \"None\" of \"Treeview | None\" has no attribute \"insert\"  [union-attr]"
          ]
        }
      }
    }
  },
  "gui/panels/entry_panel.py": {
    "docstrings": {
      "module_doc": {
        "description": "entry_panel.py\nThis module defines the EntryPanel class, which provides the interface for creating new log entries.\nCore features include:\n- Allowing users to enter and submit new log entries.\n- Integrating with the application controller to handle log submission.",
        "args": null,
        "returns": null
      },
      "classes": [
        {
          "name": "EntryPanel",
          "description": "EntryPanel provides the interface for creating new log entries.\nAttributes:\nframe (Optional[ttk.LabelFrame]): The frame containing the entry interface.\nentry_text (Optional[tk.Text]): The text widget for entering log content.\nsubmit_button (Optional[ttk.Button]): The button for submitting the log entry.",
          "args": null,
          "returns": null
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "description": "Initializes the EntryPanel with the specified parent and controller.",
          "args": "parent (tk.Widget): The parent widget for this panel.\ncontroller (Optional[object]): The controller for handling log submissions. Defaults to None.",
          "returns": null
        },
        {
          "name": "initialize_ui",
          "description": "Creates and packs the user interface components for the entry panel.",
          "args": null,
          "returns": "None"
        },
        {
          "name": "on_submit",
          "description": "Handles the submission of a new log entry.\nRetrieves text from the text widget and submits it to the controller if available.",
          "args": null,
          "returns": "None"
        },
        {
          "name": "refresh",
          "description": "Clears the text area when refreshing, if needed.",
          "args": null,
          "returns": "None"
        }
      ]
    },
    "coverage": {
      "method_diff": {
        "EntryPanel": {
          "missing": [],
          "added": [
            "__init__",
            "initialize_ui",
            "on_submit",
            "refresh"
          ]
        }
      },
      "missing_tests": [],
      "complexity": {
        "EntryPanel.__init__": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 4,
          "lines": 4,
          "covered_lines": [
            38,
            39,
            40,
            41
          ],
          "missing_lines": []
        },
        "EntryPanel.initialize_ui": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 6,
          "lines": 6,
          "covered_lines": [
            51,
            52,
            55,
            56,
            59,
            62
          ],
          "missing_lines": []
        },
        "EntryPanel.on_submit": {
          "complexity": 6,
          "coverage": 0.6,
          "hits": 7,
          "lines": 11,
          "covered_lines": [
            74,
            75,
            76,
            77,
            80,
            81,
            83
          ],
          "missing_lines": []
        },
        "EntryPanel.refresh": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 1,
          "covered_lines": [],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "mypy": {
          "errors": [
            "scripts/gui/panels/entry_panel.py:29: error: Function is missing a type annotation for one or more arguments  [no-untyped-def]",
            "scripts/gui/panels/entry_panel.py:74: error: Item \"None\" of \"Text | None\" has no attribute \"get\"  [union-attr]",
            "scripts/gui/panels/entry_panel.py:83: error: Item \"None\" of \"Text | None\" has no attribute \"delete\"  [union-attr]",
            "scripts/gui/panels/entry_panel.py:99: error: Item \"None\" of \"Text | None\" has no attribute \"delete\"  [union-attr]"
          ]
        }
      }
    }
  },
  "gui/panels/log_panel.py": {
    "docstrings": {
      "module_doc": {
        "description": "log_panel.py\nThis module defines the LogPanel class, which manages the display area for logs.\nCore features include:\n- Displaying log entries in a scrollable text area.\n- Integrating with the application controller to fetch log data.",
        "args": null,
        "returns": null
      },
      "classes": [
        {
          "name": "LogPanel",
          "description": "LogPanel manages the display area for logs.\nAttributes:\nframe (ttk.LabelFrame): The frame containing the log display.\nlog_display (scrolledtext.ScrolledText): The text area for displaying log entries.",
          "args": null,
          "returns": null
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "description": "Initializes the LogPanel with the specified parent and controller.",
          "args": "parent (tk.Widget): The parent widget for this panel.\ncontroller (Optional[object]): The controller for handling log data. Defaults to None.",
          "returns": null
        },
        {
          "name": "initialize_ui",
          "description": "Creates and packs the user interface components for the log panel.",
          "args": null,
          "returns": "None"
        },
        {
          "name": "refresh",
          "description": "Refreshes the log display area by fetching logs from the controller.",
          "args": null,
          "returns": "None"
        }
      ]
    },
    "coverage": {
      "method_diff": {
        "LogPanel": {
          "missing": [],
          "added": [
            "__init__",
            "initialize_ui",
            "refresh"
          ]
        }
      },
      "missing_tests": [],
      "complexity": {
        "LogPanel.__init__": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 3,
          "lines": 3,
          "covered_lines": [
            35,
            36,
            37
          ],
          "missing_lines": []
        },
        "LogPanel.initialize_ui": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 4,
          "lines": 4,
          "covered_lines": [
            47,
            48,
            51,
            52
          ],
          "missing_lines": []
        },
        "LogPanel.refresh": {
          "complexity": 5,
          "coverage": 0.8,
          "hits": 7,
          "lines": 8,
          "covered_lines": [
            62,
            64,
            65,
            66,
            67,
            68,
            69
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "mypy": {
          "errors": [
            "scripts/gui/panels/log_panel.py:26: error: Function is missing a type annotation for one or more arguments  [no-untyped-def]",
            "scripts/gui/panels/log_panel.py:35: error: Incompatible types in assignment (expression has type \"None\", variable has type \"Labelframe\")  [assignment]",
            "scripts/gui/panels/log_panel.py:36: error: Incompatible types in assignment (expression has type \"None\", variable has type \"ScrolledText\")  [assignment]"
          ]
        }
      }
    }
  },
  "gui/style_manager.py": {
    "docstrings": {
      "module_doc": {
        "description": "style_manager.py\nThis module defines the StyleManager class for managing application-wide styles for tkinter and ttk.\nCore features include:\n- Managing application-wide styles for tkinter and ttk.\n- Defining default colors and fonts.\n- Configuring ttk styles.\n- Updating specific styles with new options.",
        "args": null,
        "returns": null
      },
      "classes": [
        {
          "name": "StyleManager",
          "description": "Manages application-wide styles for tkinter and ttk.\nThis class can be extended to handle dynamic theme changes.\nAttributes:\nroot (Tk): The root Tkinter window.\nstyle (ttk.Style): The ttk style manager instance.",
          "args": null,
          "returns": null
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "description": "Initializes the StyleManager with the specified root window.",
          "args": "root (Tk): The root Tkinter window.",
          "returns": null
        },
        {
          "name": "initialize_styles",
          "description": "Defines default colors and fonts and configures ttk styles.",
          "args": null,
          "returns": "None"
        },
        {
          "name": "update_style",
          "description": "Update a specific style with new options.",
          "args": "style_name (str): The name of the style to update (e.g., 'TButton').\noptions (Dict[str, Any]): A dictionary of style options (e.g., {'background': 'red'}).",
          "returns": "None"
        }
      ]
    },
    "coverage": {
      "method_diff": {
        "StyleManager": {
          "missing": [],
          "added": [
            "__init__",
            "initialize_styles",
            "update_style"
          ]
        }
      },
      "missing_tests": [],
      "complexity": {
        "StyleManager.__init__": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 10,
          "covered_lines": [],
          "missing_lines": [
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37
          ]
        },
        "StyleManager.initialize_styles": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 20,
          "covered_lines": [],
          "missing_lines": [
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58
          ]
        },
        "StyleManager.update_style": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 12,
          "covered_lines": [],
          "missing_lines": [
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70,
            71
          ]
        }
      }
    },
    "linting": {
      "quality": {
        "mypy": {
          "errors": [
            "scripts/gui/style_manager.py:28: error: Name \"ttk.Tk\" is not defined  [name-defined]"
          ]
        }
      }
    }
  },
  "gui/tabs/__init__.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": []
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {}
    },
    "linting": {
      "quality": {
        "coverage": {
          "percent": 100.0
        }
      }
    }
  },
  "gui/tabs/main_tab.py": {
    "docstrings": {
      "module_doc": {
        "description": "main_tab.py\nThis module defines the MainTab class, which is the primary tab for logging functionality in the application.\nCore features include:\n- Organizing child panels for logging, coverage, entry, and actions.\n- Refreshing child panels when the tab becomes active.",
        "args": null,
        "returns": null
      },
      "classes": [
        {
          "name": "MainTab",
          "description": "MainTab is the primary tab for logging functionality.\nIt organizes child panels: LogPanel, CoveragePanel, EntryPanel, and ActionPanel.\nAttributes:\nlog_panel (LogPanel): The panel for displaying logs.\ncoverage_panel (CoveragePanel): The panel for displaying coverage information.\nentry_panel (EntryPanel): The panel for entering new log entries.\naction_panel (ActionPanel): The panel for action buttons.",
          "args": null,
          "returns": null
        }
      ],
      "functions": [
        {
          "name": "setup_tab",
          "description": "Create a container frame to hold the child panels and pack them into the tab.",
          "args": null,
          "returns": "None"
        },
        {
          "name": "on_show",
          "description": "Called when the MainTab becomes active. This refreshes all child panels.",
          "args": null,
          "returns": "None"
        }
      ]
    },
    "coverage": {
      "method_diff": {
        "MainTab": {
          "missing": [],
          "added": [
            "setup_tab",
            "on_show"
          ]
        }
      },
      "missing_tests": [],
      "complexity": {
        "MainTab.setup_tab": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 10,
          "lines": 10,
          "covered_lines": [
            41,
            42,
            45,
            46,
            49,
            50,
            53,
            54,
            57,
            58
          ],
          "missing_lines": []
        },
        "MainTab.on_show": {
          "complexity": 5,
          "coverage": 0.75,
          "hits": 8,
          "lines": 8,
          "covered_lines": [
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "pydocstyle": {
          "functions": {
            "MainTab": [
              {
                "code": "D205",
                "message": "1 blank line required between summary line and description (found 0)"
              }
            ]
          }
        }
      }
    }
  },
  "gui/widget_factory.py": {
    "docstrings": {
      "module_doc": {
        "description": "widget_factory.py\nThis module defines the WidgetFactory class for creating common widgets with standardized styling.\nCore features include:\n- Creating styled buttons, labels, entries, frames, and notebooks for Tkinter applications.\n- Providing a consistent look and feel across the application.",
        "args": null,
        "returns": null
      },
      "classes": [
        {
          "name": "WidgetFactory",
          "description": "Factory for creating common widgets with standardized styling.\nThis class provides static methods to create buttons, labels, entries, frames, and notebooks with consistent styles.",
          "args": null,
          "returns": null
        }
      ],
      "functions": [
        {
          "name": "create_button",
          "description": "Create and return a styled ttk Button.",
          "args": "parent (tk.Widget): The parent widget.\ntext (str): The text to display on the button.\ncommand (callable): The function to call when the button is clicked.\nstyle (str): The style to apply to the button. Defaults to 'TButton'.\n**options: Additional options to configure the button.",
          "returns": "ttk.Button: The created button widget."
        },
        {
          "name": "create_label",
          "description": "Create and return a styled ttk Label.",
          "args": "parent (tk.Widget): The parent widget.\ntext (str): The text to display on the label.\nstyle (str): The style to apply to the label. Defaults to 'TLabel'.\n**options: Additional options to configure the label.",
          "returns": "ttk.Label: The created label widget."
        },
        {
          "name": "create_entry",
          "description": "Create and return a ttk Entry widget.",
          "args": "parent (tk.Widget): The parent widget.\ntextvariable (Any): The variable to associate with the entry. Defaults to None.\n**options: Additional options to configure the entry.",
          "returns": "ttk.Entry: The created entry widget."
        },
        {
          "name": "create_frame",
          "description": "Create and return a ttk Frame widget.",
          "args": "parent (tk.Widget): The parent widget.\nstyle (str): The style to apply to the frame. Defaults to 'TFrame'.\n**options: Additional options to configure the frame.",
          "returns": "ttk.Frame: The created frame widget."
        },
        {
          "name": "create_notebook",
          "description": "Create and return a ttk Notebook widget.",
          "args": "parent (tk.Widget): The parent widget.\n**options: Additional options to configure the notebook.",
          "returns": "ttk.Notebook: The created notebook widget."
        }
      ]
    },
    "coverage": {
      "method_diff": {
        "WidgetFactory": {
          "missing": [],
          "added": [
            "create_button",
            "create_label",
            "create_entry",
            "create_frame",
            "create_notebook"
          ]
        }
      },
      "missing_tests": [],
      "complexity": {
        "WidgetFactory.create_button": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 17,
          "covered_lines": [],
          "missing_lines": [
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40
          ]
        },
        "WidgetFactory.create_label": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 16,
          "covered_lines": [],
          "missing_lines": [
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58
          ]
        },
        "WidgetFactory.create_entry": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 13,
          "covered_lines": [],
          "missing_lines": [
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70,
            71,
            72,
            73
          ]
        },
        "WidgetFactory.create_frame": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 13,
          "covered_lines": [],
          "missing_lines": [
            76,
            77,
            78,
            79,
            80,
            81,
            82,
            83,
            84,
            85,
            86,
            87,
            88
          ]
        },
        "WidgetFactory.create_notebook": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 12,
          "covered_lines": [],
          "missing_lines": [
            91,
            92,
            93,
            94,
            95,
            96,
            97,
            98,
            99,
            100,
            101,
            102
          ]
        }
      }
    },
    "linting": {
      "quality": {
        "mypy": {
          "errors": [
            "scripts/gui/widget_factory.py:25: error: Function \"builtins.callable\" is not valid as a type  [valid-type]"
          ]
        }
      }
    }
  },
  "indexers/__init__.py": {
    "docstrings": {
      "module_doc": {
        "description": "The `indexers` module provides classes and utilities for building, managing, and searching vector indexes over log and summary data.\nCore features include:\n- Construction of FAISS indexes for both raw log entries and summarized corrections.\n- Support for semantic search using SentenceTransformer embeddings.\n- Management of index and metadata persistence for efficient retrieval.\n- Utilities for rebuilding, updating, and searching indexes across different data granularities.\nThis module enables fast and flexible semantic search over structured and unstructured idea logs, supporting downstream applications such as idea retrieval, analytics, and intelligent querying.",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": []
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {}
    },
    "linting": {
      "quality": {
        "coverage": {
          "percent": 100.0
        }
      }
    }
  },
  "indexers/base_indexer.py": {
    "docstrings": {
      "module_doc": {
        "description": "base_indexer.py\nThis module defines the BaseIndexer class, which provides core functionality for building, saving, loading, and searching FAISS vector indexes over log and summary data.\nCore features include:\n- Initializing index and metadata paths based on project configuration and index type (summary or raw).\n- Building a FAISS index from text data using SentenceTransformer embeddings.\n- Saving and loading both the FAISS index and associated metadata.\n- Performing semantic search over indexed data, returning the most relevant results with similarity scores.\n- Supporting flexible configuration and robust error handling for index operations.\nIntended for use as a base class for specialized indexers in the Zephyrus project, enabling fast and flexible semantic search over structured logs and summaries.",
        "args": null,
        "returns": null
      },
      "classes": [
        {
          "name": "BaseIndexer",
          "description": null,
          "args": null,
          "returns": null
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "description": "Initializes the BaseIndexer object.\nSets the paths to the summaries file, FAISS index file, and metadata file based on the\nprovided `index_name` and the `ZephyrusPaths` object.  If `index_name` is \"summary\",\nthe paths are set to the correction summaries file, FAISS index file, and metadata file.\nIf `index_name` is \"raw\", the paths are set to the JSON log file, raw log index file,\nand raw log metadata file.  In all other cases, a ValueError is raised.\nAlso, loads the SentenceTransformer model specified by the \"embedding_model\"\nconfiguration key, or defaults to \"all-MiniLM-L6-v2\" if the key is missing.",
          "args": "paths (ZephyrusPaths): The paths configuration for the indexer.\nindex_name (str): The name of the index to create, either \"summary\" or \"raw\".\nRaises:\nValueError: If `index_name` is not \"summary\" or \"raw\".",
          "returns": null
        },
        {
          "name": "_load_model",
          "description": null,
          "args": null,
          "returns": null
        },
        {
          "name": "load_index",
          "description": "Loads the FAISS index and associated metadata from their respective files.\nThis method reads the index from the file specified by `self.index_path` and loads\nthe metadata from the file specified by `self.metadata_path`. If either file does not\nexist, a FileNotFoundError is raised.\nRaises:\nFileNotFoundError: If the index file or metadata file is not found.",
          "args": null,
          "returns": null
        },
        {
          "name": "search",
          "description": "Searches the FAISS index for the given query and returns the top-k most relevant results.",
          "args": "query (str): The search query.\ntop_k (int, optional): The number of top results to return. Defaults to 5.",
          "returns": "List[Dict[str, Any]]: A list of dictionaries containing the search results. Each dictionary includes the\nfollowing keys:\n- \"date\"\n- \"main_category\"\n- \"subcategory\"\n- \"timestamp\"\n- \"similarity\" (the similarity score, computed as 1.0 / (1.0 + distance))"
        },
        {
          "name": "build_index",
          "description": "Builds a FAISS index from provided texts and metadata.",
          "args": "texts (List[str]): A list of texts to encode and index.\nmeta (List[Dict[str, Any]]): Metadata per text entry.\nfail_on_empty (bool): Raise ValueError if input is empty (useful for tests).",
          "returns": "bool: True if successful, False otherwise."
        },
        {
          "name": "save_index",
          "description": "Saves the FAISS index to a file, and the associated metadata.\nThis method must be called after `build_index` or `load_index` has been called.",
          "args": null,
          "returns": null
        }
      ]
    },
    "coverage": {
      "method_diff": {
        "BaseIndexer": {
          "missing": [],
          "added": [
            "__init__",
            "_load_model",
            "load_index",
            "search",
            "build_index",
            "save_index"
          ]
        }
      },
      "missing_tests": [],
      "complexity": {
        "BaseIndexer.__init__": {
          "complexity": 3,
          "coverage": 0.7647,
          "hits": 10,
          "lines": 13,
          "covered_lines": [
            48,
            49,
            50,
            51,
            52,
            57,
            59,
            62,
            63,
            64
          ],
          "missing_lines": []
        },
        "BaseIndexer._load_model": {
          "complexity": 3,
          "coverage": 0.6667,
          "hits": 4,
          "lines": 6,
          "covered_lines": [
            67,
            68,
            72,
            75
          ],
          "missing_lines": []
        },
        "BaseIndexer.load_index": {
          "complexity": 7,
          "coverage": 0.8571,
          "hits": 9,
          "lines": 10,
          "covered_lines": [
            88,
            89,
            90,
            91,
            92,
            93,
            95,
            96,
            97
          ],
          "missing_lines": []
        },
        "BaseIndexer.search": {
          "complexity": 6,
          "coverage": 0.9444,
          "hits": 14,
          "lines": 14,
          "covered_lines": [
            117,
            118,
            119,
            121,
            122,
            123,
            124,
            125,
            126,
            128,
            129,
            130,
            131,
            132,
            133,
            134
          ],
          "missing_lines": []
        },
        "BaseIndexer.build_index": {
          "complexity": 5,
          "coverage": 0.7333,
          "hits": 10,
          "lines": 13,
          "covered_lines": [
            150,
            151,
            152,
            154,
            156,
            157,
            158,
            159,
            160,
            161,
            162
          ],
          "missing_lines": []
        },
        "BaseIndexer.save_index": {
          "complexity": 2,
          "coverage": 1.0,
          "hits": 4,
          "lines": 4,
          "covered_lines": [
            174,
            176,
            177,
            178
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "flake8": {
          "issues": [
            {
              "line": 59,
              "column": 9,
              "code": "F841",
              "message": "local variable 'model_name' is assigned to but never used"
            },
            {
              "line": 122,
              "column": 16,
              "code": "E741",
              "message": "ambiguous variable name 'I'"
            },
            {
              "line": 59,
              "column": 9,
              "code": "F841",
              "message": "local variable 'model_name' is assigned to but never used"
            },
            {
              "line": 122,
              "column": 16,
              "code": "E741",
              "message": "ambiguous variable name 'I'"
            }
          ]
        },
        "mypy": {
          "errors": [
            "scripts/indexers/base_indexer.py:60: error: Argument 1 to \"get_config_value\" has incompatible type \"AppConfig\"; expected \"dict[str, Any]\"  [arg-type]",
            "scripts/indexers/base_indexer.py:62: error: Call to untyped function \"_load_model\" in typed context  [no-untyped-call]",
            "scripts/indexers/base_indexer.py:66: error: Function is missing a return type annotation  [no-untyped-def]",
            "scripts/indexers/base_indexer.py:73: error: Argument 1 to \"get_config_value\" has incompatible type \"AppConfig\"; expected \"dict[str, Any]\"  [arg-type]",
            "scripts/indexers/base_indexer.py:159: error: \"None\" has no attribute \"add\"  [attr-defined]"
          ]
        },
        "pydocstyle": {
          "functions": {
            "BaseIndexer": [
              {
                "code": "D101",
                "message": "Missing docstring in public class"
              }
            ]
          }
        },
        "coverage": {
          "percent": 88.0
        }
      }
    }
  },
  "indexers/raw_log_indexer.py": {
    "docstrings": {
      "module_doc": {
        "description": "This module defines the RawLogIndexer class for building and managing a FAISS vector index\nover raw log entries from zephyrus_log.json.\nCore features:\n- Loading and parsing raw log entries by date, main category, and subcategory.\n- Extracting entry content and metadata for semantic indexing.\n- Building, saving, loading, and rebuilding a FAISS index for full-text vector search.\n- Robust error handling and logging for file I/O and data processing.\n- Designed for use in the Zephyrus project to enable fast, flexible semantic search.",
        "args": null,
        "returns": null
      },
      "classes": [
        {
          "name": "RawLogIndexer",
          "description": "Builds a FAISS index from raw entries in zephyrus_log.json.\nUsed for full-text vector search across all logged ideas (not just summaries).\nAttributes:\nlog_path (str): The path to the JSON log file.",
          "args": null,
          "returns": null
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "description": "Initializes the RawLogIndexer with the specified paths and optionally loads the index.",
          "args": "paths (ZephyrusPaths): The paths configuration for the indexer.\nautoload (bool): Whether to automatically load the index on initialization.\nDefaults to True.\nRaises:\nFileNotFoundError: If the index files are not found during autoload.",
          "returns": null
        },
        {
          "name": "load_entries",
          "description": "Loads raw entries from the zephyrus_log.json file.",
          "args": null,
          "returns": "Tuple[List[str], List[Dict[str, Any]]]: A tuple containing a list of entry contents\nand a list of metadata dictionaries.\nRaises:\nFileNotFoundError: If the log file does not exist.\njson.JSONDecodeError: If the JSON file is malformed."
        },
        {
          "name": "_process_categories",
          "description": "Processes categories for a given date, updating the texts and metadata.",
          "args": "date (str): The date of the entries being processed.\ncategories (Dict[str, Any]): A dictionary of main categories.\ntexts (List[str]): The list to append entry contents to.\nmeta (List[Dict[str, Any]]): The list to append entry metadata to.",
          "returns": "Tuple[List[str], List[Dict[str, Any]]]: Updated texts and metadata lists."
        },
        {
          "name": "_process_subcategories",
          "description": "Processes subcategories within a main category for a given date.",
          "args": "date (str): The date of the entries being processed.\nmain_cat (str): The main category of the entries.\nsubcats (Dict[str, Any]): A dictionary of subcategories.\ntexts (List[str]): The list to append entry contents to.\nmeta (List[Dict[str, Any]]): The list to append entry metadata to.",
          "returns": "Tuple[List[str], List[Dict[str, Any]]]: Updated texts and metadata lists."
        },
        {
          "name": "_process_entries",
          "description": "Processes a list of entries for a given date, main category, and subcategory.",
          "args": "date (str): The date of the entries being processed.\nmain_cat (str): The main category of the entries.\nsubcat (str): The subcategory of the entries.\nentries (List[Any]): A list of entries to process.\ntexts (List[str]): The list to append entry contents to.\nmeta (List[Dict[str, Any]]): The list to append entry metadata to.",
          "returns": "Tuple[List[str], List[Dict[str, Any]]]: Updated texts and metadata lists."
        },
        {
          "name": "build_index_from_logs",
          "description": "Loads entries from file and rebuilds FAISS index.",
          "args": null,
          "returns": "bool: Whether the index was successfully rebuilt.\nRaises:\nException: If an error occurs while building the index."
        },
        {
          "name": "rebuild",
          "description": "Rebuilds the raw log index from scratch.\nThis method loads entries from the log file, rebuilds the FAISS index, and saves the new index.\nRaises:\nException: If an error occurs while rebuilding the index.",
          "args": null,
          "returns": null
        }
      ]
    },
    "coverage": {
      "method_diff": {
        "RawLogIndexer": {
          "missing": [],
          "added": [
            "__init__",
            "load_entries",
            "_process_categories",
            "_process_subcategories",
            "_process_entries",
            "build_index_from_logs",
            "rebuild"
          ]
        }
      },
      "missing_tests": [],
      "complexity": {
        "RawLogIndexer.__init__": {
          "complexity": 4,
          "coverage": 0.0,
          "hits": 0,
          "lines": 6,
          "covered_lines": [],
          "missing_lines": []
        },
        "RawLogIndexer.load_entries": {
          "complexity": 9,
          "coverage": 0.7778,
          "hits": 12,
          "lines": 16,
          "covered_lines": [
            65,
            66,
            67,
            68,
            71,
            72,
            73,
            78,
            79,
            80,
            81,
            82,
            86
          ],
          "missing_lines": []
        },
        "RawLogIndexer._process_categories": {
          "complexity": 4,
          "coverage": 0.8571,
          "hits": 4,
          "lines": 5,
          "covered_lines": [
            103,
            104,
            105,
            114
          ],
          "missing_lines": []
        },
        "RawLogIndexer._process_subcategories": {
          "complexity": 4,
          "coverage": 0.8571,
          "hits": 4,
          "lines": 5,
          "covered_lines": [
            137,
            138,
            139,
            149
          ],
          "missing_lines": []
        },
        "RawLogIndexer._process_entries": {
          "complexity": 5,
          "coverage": 0.9091,
          "hits": 8,
          "lines": 9,
          "covered_lines": [
            174,
            175,
            176,
            177,
            178,
            179,
            180,
            189,
            201
          ],
          "missing_lines": []
        },
        "RawLogIndexer.build_index_from_logs": {
          "complexity": 4,
          "coverage": 0.7143,
          "hits": 5,
          "lines": 7,
          "covered_lines": [
            213,
            214,
            215,
            216,
            217,
            218
          ],
          "missing_lines": []
        },
        "RawLogIndexer.rebuild": {
          "complexity": 2,
          "coverage": 1.0,
          "hits": 3,
          "lines": 3,
          "covered_lines": [
            232,
            233,
            234,
            235
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "mypy": {
          "errors": [
            "scripts/indexers/raw_log_indexer.py:45: error: Incompatible types in assignment (expression has type \"Path\", variable has type \"str\")  [assignment]"
          ]
        }
      }
    }
  },
  "indexers/summary_indexer.py": {
    "docstrings": {
      "module_doc": {
        "description": "summary_indexer.py\nThis module defines the SummaryIndexer class for building and managing a FAISS vector index over summarized entries from correction_summaries.json.\nCore features include:\n- Loading and parsing summarized entries organized by date, main category, and subcategory.\n- Extracting summary texts and associated metadata for semantic indexing.\n- Building, saving, loading, and rebuilding a FAISS index for semantic search across all summarized corrections.\n- Robust error handling and logging for file I/O and data processing.\n- Designed for use in the Zephyrus project to enable fast, flexible semantic search over all summarized log data.",
        "args": null,
        "returns": null
      },
      "classes": [
        {
          "name": "SummaryIndexer",
          "description": "Builds a FAISS index from summarized entries in correction_summaries.json.\nCore features include loading and parsing summarized entries, extracting summary texts,\nand managing the FAISS index for semantic search.",
          "args": null,
          "returns": null
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "description": "Initializes a SummaryIndexer object.",
          "args": "paths (ZephyrusPaths): An instance containing the necessary file paths.\nautoload (bool, optional): Flag indicating whether to load the index automatically. Defaults to True.",
          "returns": null
        },
        {
          "name": "load_entries",
          "description": "Loads summarized entries from the correction_summaries.json file.",
          "args": null,
          "returns": "Tuple[List[str], List[Dict[str, Any]]]: Summarized entry texts and metadata."
        },
        {
          "name": "_process_categories",
          "description": null,
          "args": null,
          "returns": null
        },
        {
          "name": "_process_subcategories",
          "description": null,
          "args": null,
          "returns": null
        },
        {
          "name": "_process_batches",
          "description": null,
          "args": null,
          "returns": null
        },
        {
          "name": "load_index",
          "description": "Load the FAISS index and associated metadata from their respective files.\nRaises:\nFileNotFoundError: If the index file or metadata file is not found.",
          "args": null,
          "returns": null
        },
        {
          "name": "save_index",
          "description": "Save the FAISS index and associated metadata to their respective files.\nThis method delegates to the BaseIndexer implementation.",
          "args": null,
          "returns": null
        },
        {
          "name": "rebuild_index",
          "description": "Rebuild the FAISS index from the summarized entries.\nThis method invokes building index from logs and saving it.",
          "args": null,
          "returns": null
        },
        {
          "name": "build_index_from_logs",
          "description": "Loads entries from file and rebuilds FAISS index.",
          "args": null,
          "returns": "bool: Whether the index was successfully rebuilt."
        },
        {
          "name": "rebuild",
          "description": "Rebuild the summary index from scratch.",
          "args": null,
          "returns": null
        }
      ]
    },
    "coverage": {
      "method_diff": {
        "SummaryIndexer": {
          "missing": [],
          "added": [
            "__init__",
            "load_entries",
            "_process_categories",
            "_process_subcategories",
            "_process_batches",
            "load_index",
            "save_index",
            "rebuild_index",
            "build_index_from_logs",
            "rebuild"
          ]
        }
      },
      "missing_tests": [],
      "complexity": {
        "SummaryIndexer.__init__": {
          "complexity": 4,
          "coverage": 0.0,
          "hits": 0,
          "lines": 8,
          "covered_lines": [],
          "missing_lines": []
        },
        "SummaryIndexer.load_entries": {
          "complexity": 9,
          "coverage": 0.8333,
          "hits": 13,
          "lines": 16,
          "covered_lines": [
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            66,
            67,
            72,
            73,
            74,
            75,
            76,
            80
          ],
          "missing_lines": []
        },
        "SummaryIndexer._process_categories": {
          "complexity": 4,
          "coverage": 0.8571,
          "hits": 4,
          "lines": 5,
          "covered_lines": [
            85,
            86,
            87,
            92
          ],
          "missing_lines": []
        },
        "SummaryIndexer._process_subcategories": {
          "complexity": 4,
          "coverage": 0.8571,
          "hits": 4,
          "lines": 5,
          "covered_lines": [
            102,
            103,
            104,
            114
          ],
          "missing_lines": []
        },
        "SummaryIndexer._process_batches": {
          "complexity": 6,
          "coverage": 0.9,
          "hits": 7,
          "lines": 8,
          "covered_lines": [
            125,
            126,
            127,
            128,
            129,
            130,
            150
          ],
          "missing_lines": []
        },
        "SummaryIndexer.load_index": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 1,
          "lines": 1,
          "covered_lines": [
            159
          ],
          "missing_lines": []
        },
        "SummaryIndexer.save_index": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 1,
          "lines": 1,
          "covered_lines": [
            167
          ],
          "missing_lines": []
        },
        "SummaryIndexer.rebuild_index": {
          "complexity": 2,
          "coverage": 0.0,
          "hits": 0,
          "lines": 2,
          "covered_lines": [],
          "missing_lines": []
        },
        "SummaryIndexer.build_index_from_logs": {
          "complexity": 5,
          "coverage": 0.6154,
          "hits": 7,
          "lines": 11,
          "covered_lines": [
            186,
            187,
            188,
            192,
            193,
            194,
            195,
            196
          ],
          "missing_lines": []
        },
        "SummaryIndexer.rebuild": {
          "complexity": 2,
          "coverage": 1.0,
          "hits": 4,
          "lines": 4,
          "covered_lines": [
            206,
            207,
            208,
            209
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "mypy": {
          "errors": [
            "scripts/indexers/summary_indexer.py:41: error: Incompatible types in assignment (expression has type \"str\", base class \"BaseIndexer\" defined the type as \"Path\")  [assignment]"
          ]
        },
        "pydocstyle": {
          "functions": {
            "rebuild": [
              {
                "code": "D200",
                "message": "One-line docstring should fit on one line with quotes (found 3)"
              }
            ]
          }
        }
      }
    }
  },
  "kg/__init__.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": []
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {}
    },
    "linting": {}
  },
  "kg/generate_codebase_kg.py": {
    "docstrings": {
      "module_doc": {
        "description": "generate_codebase_kg.py\nBuilds Knowledge Graphs for a Python codebase using docstring summaries.\nAnalyzes module complexity (density, degree, busyness).\nColors graphs based on complexity.\nUsage:\n- Load JSON docstring summary\n- Build Parent Graph (subpackages)\n- Build Child Graphs (per subpackage)\n- Analyze complexity\n- Visualize with color-coding",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "main",
          "description": "Main entry point for the script.\nParses command-line arguments and initializes the CodebaseAnalyzer.",
          "args": null,
          "returns": null
        }
      ]
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {
        "main": {
          "complexity": 3,
          "coverage": 0.9412,
          "hits": 13,
          "lines": 13,
          "covered_lines": [
            39,
            42,
            43,
            46,
            49,
            52,
            55,
            57,
            59,
            62,
            65,
            66,
            67
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "flake8": {
          "issues": [
            {
              "line": 19,
              "column": 1,
              "code": "F401",
              "message": "'typing.Dict' imported but unused"
            },
            {
              "line": 19,
              "column": 1,
              "code": "F401",
              "message": "'typing.Any' imported but unused"
            },
            {
              "line": 19,
              "column": 1,
              "code": "F401",
              "message": "'typing.Dict' imported but unused"
            },
            {
              "line": 19,
              "column": 1,
              "code": "F401",
              "message": "'typing.Any' imported but unused"
            }
          ]
        },
        "mypy": {
          "errors": [
            "scripts/kg/generate_codebase_kg.py:33: error: Function is missing a return type annotation  [no-untyped-def]",
            "scripts/kg/generate_codebase_kg.py:71: error: Call to untyped function \"main\" in typed context  [no-untyped-call]"
          ]
        },
        "coverage": {
          "percent": 100.0
        }
      }
    }
  },
  "kg/modules/__init__.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": []
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {}
    },
    "linting": {
      "quality": {
        "coverage": {
          "percent": 100.0
        }
      }
    }
  },
  "kg/modules/analysis.py": {
    "docstrings": {
      "module_doc": {
        "description": "Complexity Analysis for Knowledge Graphs\n===============================\nThis module provides tools for analyzing the complexity of knowledge graphs.\nIt includes metrics for density, degree, busyness, and overall complexity scores.",
        "args": null,
        "returns": null
      },
      "classes": [
        {
          "name": "ComplexityAnalyzer",
          "description": "Analyzes graph complexity using various metrics.\nAttributes:\nNone\nMethods:\nanalyze_density: Analyzes the density and complexity of a given graph.",
          "args": null,
          "returns": null
        }
      ],
      "functions": [
        {
          "name": "analyze_density",
          "description": "Analyze the density and complexity of a given graph.",
          "args": "graph (nx.Graph): The graph to analyze.\nname (str): An optional name for the graph.",
          "returns": "Dict[str, Any]: A dictionary containing various metrics of the graph's complexity.\nRaises:\nNone"
        }
      ]
    },
    "coverage": {
      "method_diff": {
        "ComplexityAnalyzer": {
          "missing": [],
          "added": [
            "analyze_density"
          ]
        }
      },
      "missing_tests": [],
      "complexity": {
        "ComplexityAnalyzer.analyze_density": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 9,
          "lines": 9,
          "covered_lines": [
            40,
            41,
            44,
            45,
            46,
            49,
            50,
            53,
            61
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "coverage": {
          "percent": 100.0
        }
      }
    }
  },
  "kg/modules/data_extractors.py": {
    "docstrings": {
      "module_doc": {
        "description": "Data extractors for analyzing Python docstrings and extracting relationships.",
        "args": null,
        "returns": null
      },
      "classes": [
        {
          "name": "DataRelationExtractor",
          "description": "Extracts data relations from module docstrings.",
          "args": null,
          "returns": null
        },
        {
          "name": "FunctionExtractor",
          "description": "Extracts function parameters and return values from docstrings.",
          "args": null,
          "returns": null
        }
      ],
      "functions": [
        {
          "name": "extract_data_relations",
          "description": "Extract data relations from module docstrings using pattern matching.",
          "args": "graph: The directed graph to which data relations will be added.\nmodule_node: The module node identifier.\ndescription: The module description from which to extract relations.",
          "returns": null
        },
        {
          "name": "_add_data_node",
          "description": "Add a data node and its relation to the graph.",
          "args": "graph: The directed graph to which the node will be added.\nmodule_node: The module node identifier.\ndata_node: The data node identifier.\nrelation: The type of relation to the data node.\nconfidence: The confidence level of the relation.",
          "returns": null
        },
        {
          "name": "extract_parameters_and_returns",
          "description": "Extract parameters and return values from a function entry.",
          "args": "fn_entry: A dictionary containing function metadata.",
          "returns": "A tuple containing lists of parameters and return values."
        }
      ]
    },
    "coverage": {
      "method_diff": {
        "DataRelationExtractor": {
          "missing": [],
          "added": [
            "extract_data_relations",
            "_add_data_node"
          ]
        },
        "FunctionExtractor": {
          "missing": [],
          "added": [
            "extract_parameters_and_returns"
          ]
        }
      },
      "missing_tests": [],
      "complexity": {
        "DataRelationExtractor.extract_data_relations": {
          "complexity": 8,
          "coverage": 1.0,
          "hits": 11,
          "lines": 11,
          "covered_lines": [
            59,
            60,
            62,
            65,
            66,
            67,
            70,
            71,
            72,
            74,
            75
          ],
          "missing_lines": []
        },
        "DataRelationExtractor._add_data_node": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 2,
          "lines": 2,
          "covered_lines": [
            93,
            94
          ],
          "missing_lines": []
        },
        "FunctionExtractor.extract_parameters_and_returns": {
          "complexity": 10,
          "coverage": 0.925,
          "hits": 22,
          "lines": 22,
          "covered_lines": [
            111,
            112,
            115,
            116,
            117,
            118,
            119,
            120,
            121,
            122,
            125,
            126,
            127,
            128,
            129,
            130,
            131,
            132,
            134,
            135,
            136,
            138
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "coverage": {
          "percent": 100.0
        }
      }
    }
  },
  "kg/modules/graph_builder.py": {
    "docstrings": {
      "module_doc": {
        "description": "Knowledge graph construction and management tools.",
        "args": null,
        "returns": null
      },
      "classes": [
        {
          "name": "KnowledgeGraphBuilder",
          "description": "Builds knowledge graphs from docmap data.",
          "args": null,
          "returns": null
        },
        {
          "name": "CodebaseAnalyzer",
          "description": "Main class for analyzing and visualizing codebase knowledge graphs.",
          "args": null,
          "returns": null
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "description": "Initialize with normalized docmap data.",
          "args": "docmap: A dictionary mapping module paths to their data attributes.",
          "returns": null
        },
        {
          "name": "build_knowledge_graph",
          "description": "Constructs a knowledge graph from the docmap data, optionally filtering by prefix.",
          "args": "focus_prefix: Optional prefix to filter modules.",
          "returns": "A directed graph representing the relationships between modules and their data."
        },
        {
          "name": "_build_graph",
          "description": "Build the knowledge graph from the filtered docmap.",
          "args": "docmap: A filtered dictionary mapping module paths to their data attributes.",
          "returns": "A directed graph representing the relationships."
        },
        {
          "name": "__init__",
          "description": "Initialize the analyzer with JSON data.",
          "args": "json_path: Path to the docstring summary JSON file\nfocus_prefix: Prefix to filter modules",
          "returns": null
        },
        {
          "name": "analyze",
          "description": "Analyze the codebase and build knowledge graph.",
          "args": null,
          "returns": "Tuple containing the graph and complexity report"
        },
        {
          "name": "visualize",
          "description": "Visualize the knowledge graph with complexity indicators.",
          "args": "graph: The knowledge graph\ndensity_report: Complexity metrics report",
          "returns": null
        },
        {
          "name": "export_graph",
          "description": "Export the graph to a file.",
          "args": "graph: The knowledge graph\nformat_type: Export format ('graphml' or 'gexf')",
          "returns": "Filename of the exported graph"
        }
      ]
    },
    "coverage": {
      "method_diff": {
        "KnowledgeGraphBuilder": {
          "missing": [],
          "added": [
            "__init__",
            "build_knowledge_graph",
            "_build_graph"
          ]
        },
        "CodebaseAnalyzer": {
          "missing": [],
          "added": [
            "__init__",
            "analyze",
            "visualize",
            "export_graph"
          ]
        }
      },
      "missing_tests": [],
      "complexity": {
        "KnowledgeGraphBuilder.__init__": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 1,
          "lines": 1,
          "covered_lines": [
            26
          ],
          "missing_lines": []
        },
        "KnowledgeGraphBuilder.build_knowledge_graph": {
          "complexity": 4,
          "coverage": 1.0,
          "hits": 4,
          "lines": 4,
          "covered_lines": [
            39,
            40,
            41,
            43
          ],
          "missing_lines": []
        },
        "KnowledgeGraphBuilder._build_graph": {
          "complexity": 17,
          "coverage": 0.8378,
          "hits": 40,
          "lines": 46,
          "covered_lines": [
            55,
            56,
            58,
            59,
            60,
            63,
            64,
            65,
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74,
            76,
            79,
            80,
            81,
            82,
            85,
            86,
            87,
            88,
            89,
            92,
            93,
            94,
            95,
            96,
            98,
            101,
            107,
            113,
            114,
            115,
            116,
            117,
            119
          ],
          "missing_lines": []
        },
        "CodebaseAnalyzer.__init__": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 3,
          "covered_lines": [],
          "missing_lines": []
        },
        "CodebaseAnalyzer.analyze": {
          "complexity": 2,
          "coverage": 0.0,
          "hits": 0,
          "lines": 8,
          "covered_lines": [],
          "missing_lines": []
        },
        "CodebaseAnalyzer.visualize": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 4,
          "covered_lines": [],
          "missing_lines": []
        },
        "CodebaseAnalyzer.export_graph": {
          "complexity": 3,
          "coverage": 0.0,
          "hits": 0,
          "lines": 6,
          "covered_lines": [],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "mypy": {
          "errors": [
            "scripts/kg/modules/graph_builder.py:172: error: Call to untyped function \"GraphVisualizer\" in typed context  [no-untyped-call]"
          ]
        }
      }
    }
  },
  "kg/modules/utils.py": {
    "docstrings": {
      "module_doc": {
        "description": "Utility functions for the codebase analysis and graph generation.",
        "args": null,
        "returns": null
      },
      "classes": [
        {
          "name": "DocMapNormalizer",
          "description": "Handles normalization of module path keys in docmap dictionaries.",
          "args": null,
          "returns": null
        }
      ],
      "functions": [
        {
          "name": "load_json_file",
          "description": "Load and parse a JSON file.",
          "args": "file_path: Path to the JSON file.",
          "returns": "The parsed JSON content or empty dict on error."
        },
        {
          "name": "safe_get",
          "description": "Safely get a value from a dictionary.",
          "args": "data: Dictionary to get value from.\nkey: Key to lookup.\ndefault: Default value if key not found.",
          "returns": "The value from the dictionary or default."
        },
        {
          "name": "normalize_keys",
          "description": "Normalize all keys to use forward slashes for consistency.",
          "args": "docmap: A dictionary mapping module paths to their respective data.",
          "returns": "A new dictionary with normalized keys."
        }
      ]
    },
    "coverage": {
      "method_diff": {
        "DocMapNormalizer": {
          "missing": [],
          "added": [
            "normalize_keys"
          ]
        }
      },
      "missing_tests": [],
      "complexity": {
        "load_json_file": {
          "complexity": 6,
          "coverage": 0.0,
          "hits": 0,
          "lines": 12,
          "covered_lines": [],
          "missing_lines": []
        },
        "safe_get": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 1,
          "covered_lines": [],
          "missing_lines": []
        },
        "DocMapNormalizer.normalize_keys": {
          "complexity": 3,
          "coverage": 0.0,
          "hits": 0,
          "lines": 1,
          "covered_lines": [],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "mypy": {
          "errors": [
            "scripts/kg/modules/utils.py:31: error: Returning Any from function declared to return \"dict[str, dict[str, Any]]\"  [no-any-return]"
          ]
        }
      }
    }
  },
  "kg/modules/visualization.py": {
    "docstrings": {
      "module_doc": {
        "description": "Visualization tools for knowledge graphs.",
        "args": null,
        "returns": null
      },
      "classes": [
        {
          "name": "GraphVisualizer",
          "description": "Handles visualization of knowledge graphs with complexity information.",
          "args": null,
          "returns": null
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "description": "Initialize the visualizer.",
          "args": null,
          "returns": null
        },
        {
          "name": "visualize_graph",
          "description": "Visualize the graph with complexity scores.",
          "args": "graph: The graph to visualize.\ncomplexity_scores: A dictionary of complexity scores for nodes.\ntitle: The title of the visualization.",
          "returns": null
        },
        {
          "name": "_position_nodes_in_layers",
          "description": "Position nodes in horizontal layers by type.",
          "args": "layers: Dictionary of node types and their nodes.",
          "returns": "Dictionary of node positions."
        },
        {
          "name": "_handle_remaining_nodes",
          "description": "Add positions for any nodes that weren't positioned in the initial layout.\nThis modifies the pos dictionary in-place.",
          "args": "pos: Dictionary of node positions to update.",
          "returns": null
        },
        {
          "name": "_draw_module_rectangles",
          "description": "Draw colored rectangles around modules based on complexity.",
          "args": "ax: Matplotlib axes to draw on.\nmodules: Dictionary of module nodes.\npos: Dictionary of node positions.\ncomplexity_scores: Dictionary of complexity scores.",
          "returns": null
        },
        {
          "name": "_get_node_colors",
          "description": "Get node colors based on node type and module complexity.",
          "args": "graph: The knowledge graph.\ncomplexity_scores: Dictionary of complexity scores.",
          "returns": "List of colors for each node."
        },
        {
          "name": "_get_complexity_color",
          "description": "Get the color representation based on the complexity score.",
          "args": "score: The complexity score.",
          "returns": "The color corresponding to the complexity score."
        },
        {
          "name": "_shorten_label",
          "description": "Shorten a label for display purposes.",
          "args": "name: The label to shorten.",
          "returns": "The shortened label."
        }
      ]
    },
    "coverage": {
      "method_diff": {
        "GraphVisualizer": {
          "missing": [],
          "added": [
            "__init__",
            "visualize_graph",
            "_position_nodes_in_layers",
            "_handle_remaining_nodes",
            "_draw_module_rectangles",
            "_get_node_colors",
            "_get_complexity_color",
            "_shorten_label"
          ]
        }
      },
      "missing_tests": [],
      "complexity": {
        "GraphVisualizer.__init__": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 1,
          "lines": 1,
          "covered_lines": [
            19
          ],
          "missing_lines": []
        },
        "GraphVisualizer.visualize_graph": {
          "complexity": 10,
          "coverage": 0.0,
          "hits": 0,
          "lines": 25,
          "covered_lines": [],
          "missing_lines": []
        },
        "GraphVisualizer._position_nodes_in_layers": {
          "complexity": 3,
          "coverage": 0.8571,
          "hits": 9,
          "lines": 10,
          "covered_lines": [
            104,
            105,
            106,
            108,
            109,
            110,
            111,
            115,
            117
          ],
          "missing_lines": []
        },
        "GraphVisualizer._handle_remaining_nodes": {
          "complexity": 6,
          "coverage": 0.2105,
          "hits": 3,
          "lines": 9,
          "covered_lines": [
            128,
            129,
            130
          ],
          "missing_lines": []
        },
        "GraphVisualizer._draw_module_rectangles": {
          "complexity": 8,
          "coverage": 0.0,
          "hits": 0,
          "lines": 18,
          "covered_lines": [],
          "missing_lines": []
        },
        "GraphVisualizer._get_node_colors": {
          "complexity": 3,
          "coverage": 0.0,
          "hits": 0,
          "lines": 9,
          "covered_lines": [],
          "missing_lines": []
        },
        "GraphVisualizer._get_complexity_color": {
          "complexity": 3,
          "coverage": 1.0,
          "hits": 5,
          "lines": 5,
          "covered_lines": [
            244,
            245,
            246,
            247,
            249
          ],
          "missing_lines": []
        },
        "GraphVisualizer._shorten_label": {
          "complexity": 3,
          "coverage": 1.0,
          "hits": 5,
          "lines": 5,
          "covered_lines": [
            262,
            263,
            264,
            265,
            267
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "flake8": {
          "issues": [
            {
              "line": 9,
              "column": 1,
              "code": "F401",
              "message": "'typing.Any' imported but unused"
            },
            {
              "line": 160,
              "column": 13,
              "code": "F841",
              "message": "local variable 'parent' is assigned to but never used"
            },
            {
              "line": 9,
              "column": 1,
              "code": "F401",
              "message": "'typing.Any' imported but unused"
            },
            {
              "line": 160,
              "column": 13,
              "code": "F841",
              "message": "local variable 'parent' is assigned to but never used"
            }
          ]
        },
        "mypy": {
          "errors": [
            "scripts/kg/modules/visualization.py:17: error: Function is missing a return type annotation  [no-untyped-def]",
            "scripts/kg/modules/visualization.py:35: error: \"Figure\" has no attribute \"graph\"  [attr-defined]",
            "scripts/kg/modules/visualization.py:38: error: Need type annotation for \"layers\"  [var-annotated]",
            "scripts/kg/modules/visualization.py:42: error: Need type annotation for \"modules\" (hint: \"modules: dict[<type>, <type>] = ...\")  [var-annotated]",
            "scripts/kg/modules/visualization.py:94: error: Missing type parameters for generic type \"list\"  [type-arg]",
            "scripts/kg/modules/visualization.py:94: error: Missing type parameters for generic type \"tuple\"  [type-arg]",
            "scripts/kg/modules/visualization.py:119: error: Missing type parameters for generic type \"tuple\"  [type-arg]",
            "scripts/kg/modules/visualization.py:128: error: \"Figure\" has no attribute \"graph\"  [attr-defined]",
            "scripts/kg/modules/visualization.py:141: error: Name \"plt.Axes\" is not defined  [name-defined]",
            "scripts/kg/modules/visualization.py:142: error: Missing type parameters for generic type \"list\"  [type-arg]",
            "scripts/kg/modules/visualization.py:143: error: Missing type parameters for generic type \"tuple\"  [type-arg]",
            "scripts/kg/modules/visualization.py:155: error: \"Figure\" has no attribute \"graph\"  [attr-defined]",
            "scripts/kg/modules/visualization.py:202: error: Missing type parameters for generic type \"list\"  [type-arg]"
          ]
        },
        "pydocstyle": {
          "functions": {
            "_handle_remaining_nodes": [
              {
                "code": "D205",
                "message": "1 blank line required between summary line and description (found 0)"
              }
            ]
          }
        },
        "coverage": {
          "percent": 40.4
        }
      }
    }
  },
  "main.py": {
    "docstrings": {
      "module_doc": {
        "description": "main.py\nThis module provides the entrypoint for the Zephyrus Logger application.\nIt initializes the logging system, loads the application configuration, and\nsets up the GUI or CLI depending on the mode specified in the configuration.\nKey features include:\n- Logging setup\n- Config loading\n- GUI or CLI setup\n- Controller and GUI instance initialization\nThis is the main entrypoint for the Zephyrus Logger application.",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "bootstrap",
          "description": "Bootstraps the Zephyrus Logger application.",
          "args": "start_gui (bool, optional): Whether to launch the GUI. Defaults to True.",
          "returns": "Tuple[GUIController, ZephyrusLoggerGUI | None]: The controller and GUI instance (None if headless).\nRaises:\nException: Propagates any fatal errors encountered during initialization."
        }
      ]
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {
        "bootstrap": {
          "complexity": 8,
          "coverage": 0.5652,
          "hits": 12,
          "lines": 21,
          "covered_lines": [
            39,
            42,
            43,
            44,
            46,
            47,
            49,
            51,
            52,
            55,
            56,
            61,
            62,
            74
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "coverage": {
          "percent": 67.9
        }
      }
    }
  },
  "paths.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [
        {
          "name": "ZephyrusPaths",
          "description": "Dataclass for managing and resolving all Zephyrus project file and directory paths.\nProvides methods to construct absolute paths for logs, exports, configuration, and vector store files,\nwith support for test mode path overrides based on the loaded configuration.",
          "args": null,
          "returns": null
        }
      ],
      "functions": [
        {
          "name": "_resolve_path",
          "description": "Resolve an absolute Path for a given config key, falling back to the provided default if the key is missing.",
          "args": "config (dict): The configuration dictionary.\nkey (str): The configuration key to look up.\ndefault (Any): The default value to use if the key is not present.",
          "returns": "Path: The resolved absolute path."
        },
        {
          "name": "from_config",
          "description": "Constructs a ZephyrusPaths instance by resolving all required file and directory paths from the loaded configuration.\nAutomatically applies test mode path overrides if enabled.",
          "args": "script_dir (Path): The directory containing the current script.",
          "returns": "ZephyrusPaths: An instance with all paths resolved according to the configuration."
        }
      ]
    },
    "coverage": {
      "method_diff": {
        "ZephyrusPaths": {
          "missing": [],
          "added": [
            "_resolve_path",
            "from_config"
          ]
        }
      },
      "missing_tests": [],
      "complexity": {
        "ZephyrusPaths._resolve_path": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 1,
          "lines": 1,
          "covered_lines": [
            42
          ],
          "missing_lines": []
        },
        "ZephyrusPaths.from_config": {
          "complexity": 2,
          "coverage": 0.8571,
          "hits": 17,
          "lines": 19,
          "covered_lines": [
            57,
            58,
            61,
            63,
            64,
            65,
            70,
            74,
            77,
            80,
            81,
            82,
            84,
            87,
            90,
            93,
            97
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "mypy": {
          "errors": [
            "scripts/paths.py:30: error: Function is missing a type annotation for one or more arguments  [no-untyped-def]"
          ]
        }
      }
    }
  },
  "refactor/__init__.py": {
    "docstrings": {
      "module_doc": {
        "description": "The `refactor` module provides tools for analyzing, comparing, and validating Python code refactoring.\nCore functionality includes:\n- Comparing original and refactored Python modules or directories to detect changes in class and method definitions.\n- Analyzing cyclomatic complexity of functions and methods to ensure maintainability.\n- Identifying missing or insufficient test coverage for public methods.\n- Integrating with code coverage data to enrich analysis results.\n- Supporting configuration for complexity thresholds and file/directory ignore patterns.\nThis module is intended to help developers and teams maintain code quality and test coverage during refactoring processes.",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": []
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {}
    },
    "linting": {
      "quality": {
        "coverage": {
          "percent": 100.0
        }
      }
    }
  },
  "refactor/ast_extractor.py": {
    "docstrings": {
      "module_doc": {
        "description": "ast_extractor.py\nThis module provides utilities for analyzing Python source files using the AST (Abstract Syntax Tree) to extract class and method information.\nCore features include:\n- Extracting all classes and their methods from a Python file, including method start and end line numbers.\n- Supporting nested class and method extraction.\n- Comparing two sets of class methods to identify missing or newly added methods after refactoring.\n- Providing a ClassMethodInfo class to encapsulate class and method metadata for further analysis.\nIntended for use in code analysis, refactoring tools, and automated quality checks.",
        "args": null,
        "returns": null
      },
      "classes": [
        {
          "name": "ClassMethodInfo",
          "description": "Holds information about methods in a single class.\nAttributes:\nclass_name (str): Name of the class.\nmethods (Dict[str, Tuple[int, int]]): Mapping from method name to a tuple of (start_lineno, end_lineno).",
          "args": null,
          "returns": null
        },
        {
          "name": "ClassMethodExtractor",
          "description": null,
          "args": null,
          "returns": null
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "description": "Initializes ClassMethodInfo with the class name and an empty methods dictionary.",
          "args": "class_name (str): The name of the class.",
          "returns": null
        },
        {
          "name": "add_method",
          "description": "Record a method with its start and end line numbers.",
          "args": "name (str): The name of the method.\nlinenos (Tuple[int, int]): A tuple containing the start and end line numbers of the method.",
          "returns": null
        },
        {
          "name": "__repr__",
          "description": "Returns a string representation of the ClassMethodInfo instance.",
          "args": null,
          "returns": "str: A string representation of the class and its methods."
        },
        {
          "name": "extract_class_methods",
          "description": "Extracts all classes and their methods from a Python file, including method start and end line numbers.",
          "args": "file_path (str): Path to the Python source file.",
          "returns": "List[ClassMethodInfo]: A list of ClassMethodInfo instances containing class and method data."
        },
        {
          "name": "__init__",
          "description": null,
          "args": null,
          "returns": null
        },
        {
          "name": "visit_ClassDef",
          "description": null,
          "args": null,
          "returns": null
        },
        {
          "name": "generic_visit",
          "description": "Visit all child nodes, to catch nested class definitions.",
          "args": null,
          "returns": null
        },
        {
          "name": "compare_class_methods",
          "description": "Compare two ClassMethodInfo objects and return which methods are missing in the refactored version and which are newly added.",
          "args": "original (ClassMethodInfo): The original class method info.\nrefactored (ClassMethodInfo): The refactored class method info.",
          "returns": "Dict[str, List[str]]: A dictionary with keys 'missing' and 'added', each mapping to a sorted list of method names."
        }
      ]
    },
    "coverage": {
      "method_diff": {
        "ClassMethodInfo": {
          "missing": [],
          "added": [
            "__init__",
            "add_method",
            "__repr__"
          ]
        },
        "ClassMethodExtractor": {
          "missing": [],
          "added": [
            "__init__",
            "visit_ClassDef",
            "generic_visit"
          ]
        }
      },
      "missing_tests": [],
      "complexity": {
        "ClassMethodInfo.__init__": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 2,
          "lines": 2,
          "covered_lines": [
            35,
            36
          ],
          "missing_lines": []
        },
        "ClassMethodInfo.add_method": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 1,
          "lines": 1,
          "covered_lines": [
            46
          ],
          "missing_lines": []
        },
        "ClassMethodInfo.__repr__": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 1,
          "covered_lines": [],
          "missing_lines": []
        },
        "extract_class_methods": {
          "complexity": 2,
          "coverage": 1.0,
          "hits": 10,
          "lines": 10,
          "covered_lines": [
            70,
            71,
            72,
            74,
            75,
            78,
            97,
            101,
            102,
            103
          ],
          "missing_lines": []
        },
        "compare_class_methods": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 5,
          "lines": 5,
          "covered_lines": [
            119,
            120,
            122,
            123,
            125
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "mypy": {
          "errors": [
            "scripts/refactor/ast_extractor.py:75: error: Function is missing a return type annotation  [no-untyped-def]",
            "scripts/refactor/ast_extractor.py:79: error: \"AST\" has no attribute \"name\"  [attr-defined]",
            "scripts/refactor/ast_extractor.py:80: error: \"AST\" has no attribute \"body\"  [attr-defined]",
            "scripts/refactor/ast_extractor.py:90: error: \"AST\" has no attribute \"body\"  [attr-defined]",
            "scripts/refactor/ast_extractor.py:101: error: Call to untyped function \"ClassMethodExtractor\" in typed context  [no-untyped-call]"
          ]
        }
      }
    }
  },
  "refactor/code_generation/__init__.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": []
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {}
    },
    "linting": {
      "quality": {
        "coverage": {
          "percent": 100.0
        }
      }
    }
  },
  "refactor/code_generation/code_cli.py": {
    "docstrings": {
      "module_doc": {
        "description": "Zephyrus unified CLI (v2)\n==========================\nA single commandline entry point that surfaces **all existing backend capabilities discovered in the parsed *docstring_summary.json*.  The CLI now covers four pillars:\n1.  **Idea Logger**        capture & retrieve raw notes\n2.  **Summariser**         AI docstringstyle summaries\n3.  **KnowledgeGraph**    build / query graph (stub until impl.)\n4.  **RefactorGuard**      guarded code generation / refactoring\n5.  **CI Analytics**       codequality reports + metric trends\n6.  **Developer helpers**  Git branch suggester\nIt is built with **Typer** and keeps zero logic inside: every verb delegates to functions/classes already present in the codebase, or  where a module is still future work  a soft stub prints a helpful TODO but does not break the flow.\nInstall & run:\n--------------\n$ poetry install  # or pip install -e .[cli]\n$ zephyrus --help\nExamples:\n---------\n Log + summarise + KG update + guarded implementation + CI report oneliner:\nzephyrus pipe         --note \"Graph prompts reduce hallucinations\"         --main Research --sub LLMs         --refactor \"def add(a: int, b: int) -> int\"         --ci-report\n Standalone guarded function generation:\nzephyrus generate \"def slugify(text: str) -> str\"\npyproject entrypoint:\n----------------------\n[tool.poetry.scripts]\nzephyrus = \"scripts.cli.cli:app\"",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "_safe_import",
          "description": "Dynamically import a module.",
          "args": "path (str): Module path.\nstub_attrs (Optional[dict]): Stub attributes.",
          "returns": "module: Imported module."
        },
        {
          "name": "_core",
          "description": "Get the core logger instance.",
          "args": null,
          "returns": "core_mod.ZephyrusLoggerCore: Core logger instance."
        },
        {
          "name": "_ctrl",
          "description": "Get the GUI controller instance.",
          "args": null,
          "returns": "ctrl_mod.GUIController: GUI controller instance."
        },
        {
          "name": "log",
          "description": "Write a raw idea; (optionally) summarise immediately.",
          "args": "note (str): Raw idea text.\nmain (str): Main category.\nsub (str): Subcategory.\nsummarize_immediately (bool): Whether to summarise immediately.",
          "returns": null
        },
        {
          "name": "summarize",
          "description": "Summarise *all* unsummarised entries.",
          "args": null,
          "returns": null
        },
        {
          "name": "kg_build",
          "description": "Build the knowledge graph.",
          "args": "since (Optional[str]): Only build from notes after YYYYMMDD.",
          "returns": null
        },
        {
          "name": "kg_query",
          "description": "Query the knowledge graph.",
          "args": "entity (str): Entity or node label.",
          "returns": null
        },
        {
          "name": "generate_function",
          "description": "Generate a function using RefactorGuard.",
          "args": "signature (str): Python signature e.g. 'add(a: int, b: int) -> int'.\ncontext_entity (Optional[str]): KG entity to give as context.\ntests (Optional[Path]): Optional pytest file used as acceptance guard.\nmax_tokens (int): Token limit for LLM.",
          "returns": null
        },
        {
          "name": "search",
          "description": "Search for entries.",
          "args": "query (str): Search query.\nmode (str): Search mode (summary | raw).\nk (int): Number of results to return.",
          "returns": null
        },
        {
          "name": "coverage",
          "description": "Get coverage data.",
          "args": null,
          "returns": null
        },
        {
          "name": "rebuild_index",
          "description": "Rebuild the index.",
          "args": "index (str): Index to rebuild (summary | raw | all).",
          "returns": null
        },
        {
          "name": "ci_report",
          "description": "Generate a CI report.",
          "args": "audit (Path): Audit file.\nout (Path): Output file.",
          "returns": null
        },
        {
          "name": "ci_trends",
          "description": "Get CI trends.",
          "args": "audit (Path): Audit file.\nhistory (Path): History file.",
          "returns": null
        },
        {
          "name": "git_new_branch",
          "description": "Switch to a new Git branch.",
          "args": null,
          "returns": null
        },
        {
          "name": "pipe",
          "description": "Complete flow: log  summarise  KG build  optional guarded generation  optional CI report.",
          "args": "note (str): Idea text.\nmain (str): Main category.\nsub (str): Subcategory.\nrefactor (Optional[str]): Signature for guarded generation.\nci_report (bool): Whether to run CI report at the end.",
          "returns": null
        }
      ]
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {
        "_safe_import": {
          "complexity": 4,
          "coverage": 0.0,
          "hits": 0,
          "lines": 5,
          "covered_lines": [],
          "missing_lines": []
        },
        "_core": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 1,
          "covered_lines": [],
          "missing_lines": []
        },
        "_ctrl": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 1,
          "covered_lines": [],
          "missing_lines": []
        },
        "log": {
          "complexity": 3,
          "coverage": 0.0,
          "hits": 0,
          "lines": 8,
          "covered_lines": [],
          "missing_lines": []
        },
        "summarize": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 2,
          "covered_lines": [],
          "missing_lines": []
        },
        "kg_build": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 1,
          "covered_lines": [],
          "missing_lines": []
        },
        "kg_query": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 2,
          "covered_lines": [],
          "missing_lines": []
        },
        "generate_function": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 4,
          "covered_lines": [],
          "missing_lines": []
        },
        "search": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 3,
          "covered_lines": [],
          "missing_lines": []
        },
        "coverage": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 1,
          "covered_lines": [],
          "missing_lines": []
        },
        "rebuild_index": {
          "complexity": 5,
          "coverage": 0.0,
          "hits": 0,
          "lines": 7,
          "covered_lines": [],
          "missing_lines": []
        },
        "ci_report": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 4,
          "covered_lines": [],
          "missing_lines": []
        },
        "ci_trends": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 5,
          "covered_lines": [],
          "missing_lines": []
        },
        "git_new_branch": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 0,
          "lines": 0,
          "covered_lines": [],
          "missing_lines": []
        },
        "pipe": {
          "complexity": 4,
          "coverage": 0.0,
          "hits": 0,
          "lines": 11,
          "covered_lines": [],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "flake8": {
          "issues": [
            {
              "line": 43,
              "column": 1,
              "code": "F401",
              "message": "'sys' imported but unused"
            },
            {
              "line": 54,
              "column": 67,
              "code": "F821",
              "message": "undefined name 'module'"
            },
            {
              "line": 43,
              "column": 1,
              "code": "F401",
              "message": "'sys' imported but unused"
            },
            {
              "line": 54,
              "column": 67,
              "code": "F821",
              "message": "undefined name 'module'"
            }
          ]
        },
        "mypy": {
          "errors": [
            "scripts/refactor/code_generation/code_cli.py:54: error: Missing type parameters for generic type \"dict\"  [type-arg]",
            "scripts/refactor/code_generation/code_cli.py:54: error: Name \"module\" is not defined  [name-defined]",
            "scripts/refactor/code_generation/code_cli.py:68: error: Unused \"type: ignore\" comment  [unused-ignore]",
            "scripts/refactor/code_generation/code_cli.py:400: error: \"Literal[True]\" not callable  [misc]"
          ]
        },
        "black": {
          "needs_formatting": true
        },
        "pydocstyle": {
          "functions": {
            "summarize": [
              {
                "code": "D200",
                "message": "One-line docstring should fit on one line with quotes (found 3)"
              }
            ],
            "coverage": [
              {
                "code": "D200",
                "message": "One-line docstring should fit on one line with quotes (found 3)"
              }
            ],
            "git_new_branch": [
              {
                "code": "D200",
                "message": "One-line docstring should fit on one line with quotes (found 3)"
              }
            ]
          }
        },
        "coverage": {
          "percent": 0.0
        }
      }
    }
  },
  "refactor/complexity/__init__.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": []
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {}
    },
    "linting": {
      "quality": {
        "coverage": {
          "percent": 100.0
        }
      }
    }
  },
  "refactor/complexity/complexity_analyzer.py": {
    "docstrings": {
      "module_doc": {
        "description": "complexity_analyzer.py\nThis module provides utilities for analyzing the cyclomatic complexity of Python functions, methods, and modules using the AST (Abstract Syntax Tree).\nCore features include:\n- Computing cyclomatic complexity for each function and method in a Python file, including support for nested classes.\n- Summing per-function complexities to produce a module-level complexity score.\n- Supporting Python 3.10+ match/case syntax in complexity calculations.\n- Providing a ComplexityVisitor class for AST traversal and complexity computation.\n- Handling syntax and I/O errors gracefully with warnings.\n- Deprecated alias for backward compatibility.\nIntended for use in code quality analysis, refactoring tools, and CI pipelines to help maintain manageable code complexity.",
        "args": null,
        "returns": null
      },
      "classes": [
        {
          "name": "ComplexityVisitor",
          "description": "Visits each top-level function or method definition and computes\nits cyclomatic complexity based on decision point nodes.\nNested functions are entirely skipped; nested classes are recursed into.",
          "args": null,
          "returns": null
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "description": "Initializes the ComplexityVisitor with an empty dictionary for function scores\nand sets the current class name to an empty string.",
          "args": null,
          "returns": "None"
        },
        {
          "name": "visit_ClassDef",
          "description": "Visits a class definition node and computes the complexity of its methods.",
          "args": "node (ast.ClassDef): The class definition node to visit.",
          "returns": "None"
        },
        {
          "name": "visit_FunctionDef",
          "description": "Visits a function definition node and calculates its complexity.",
          "args": "node (ast.FunctionDef): The function definition node to visit.",
          "returns": "None"
        },
        {
          "name": "visit_AsyncFunctionDef",
          "description": "Visits an asynchronous function definition node and calculates its complexity.",
          "args": "node (ast.AsyncFunctionDef): The asynchronous function definition node to visit.",
          "returns": "None"
        },
        {
          "name": "_compute_and_record",
          "description": "Calculate complexity for a function/method node and record it.",
          "args": "node (ast.AST): The function or method node to analyze.",
          "returns": "None"
        },
        {
          "name": "count_nodes",
          "description": "Recursively counts the number of decision nodes in the given AST node.",
          "args": "n (ast.AST): The AST node to count decision nodes in.",
          "returns": "int: The number of decision nodes in the given AST node."
        },
        {
          "name": "get_scores",
          "description": "Return the computed complexity scores.",
          "args": null,
          "returns": "Dict[str, int]: A dictionary mapping function/method names to their complexity scores."
        },
        {
          "name": "calculate_function_complexity_map",
          "description": "Parses the given Python file and returns a mapping from function/method\nfull names to their cyclomatic complexity scores.",
          "args": "file_path (str): Path to the Python source file.",
          "returns": "Dict[str, int]: A mapping of function/method names to their complexity scores.\nOn parse errors, prints a warning and returns an empty dict."
        },
        {
          "name": "calculate_module_complexity",
          "description": "Sum all function/method complexities in the module and add 1 overhead.",
          "args": "module_path (str): Path to the Python module.",
          "returns": "int: The total complexity score for the module, or -1 on error."
        },
        {
          "name": "calculate_cyclomatic_complexity_for_module",
          "description": "Deprecated alias for calculate_module_complexity.\nIssues a DeprecationWarning and delegates to calculate_module_complexity.",
          "args": "module_path (str): Path to the Python module.",
          "returns": "int: The total complexity score for the module, or -1 on error."
        }
      ]
    },
    "coverage": {
      "method_diff": {
        "ComplexityVisitor": {
          "missing": [],
          "added": [
            "__init__",
            "visit_ClassDef",
            "visit_FunctionDef",
            "visit_AsyncFunctionDef",
            "_compute_and_record",
            "get_scores"
          ]
        }
      },
      "missing_tests": [],
      "complexity": {
        "ComplexityVisitor.__init__": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 2,
          "lines": 2,
          "covered_lines": [
            65,
            66
          ],
          "missing_lines": []
        },
        "ComplexityVisitor.visit_ClassDef": {
          "complexity": 5,
          "coverage": 0.8235,
          "hits": 8,
          "lines": 9,
          "covered_lines": [
            78,
            79,
            82,
            83,
            84,
            87,
            88,
            91
          ],
          "missing_lines": []
        },
        "ComplexityVisitor.visit_FunctionDef": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 1,
          "lines": 1,
          "covered_lines": [
            103
          ],
          "missing_lines": []
        },
        "ComplexityVisitor.visit_AsyncFunctionDef": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 1,
          "lines": 1,
          "covered_lines": [
            115
          ],
          "missing_lines": []
        },
        "ComplexityVisitor._compute_and_record": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 5,
          "lines": 5,
          "covered_lines": [
            128,
            148,
            149,
            150,
            151
          ],
          "missing_lines": []
        },
        "ComplexityVisitor.get_scores": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 1,
          "lines": 1,
          "covered_lines": [
            160
          ],
          "missing_lines": []
        },
        "calculate_function_complexity_map": {
          "complexity": 4,
          "coverage": 1.0,
          "hits": 10,
          "lines": 10,
          "covered_lines": [
            176,
            177,
            178,
            179,
            180,
            181,
            182,
            184,
            185,
            186
          ],
          "missing_lines": []
        },
        "calculate_module_complexity": {
          "complexity": 4,
          "coverage": 1.0,
          "hits": 9,
          "lines": 9,
          "covered_lines": [
            200,
            201,
            202,
            203,
            204,
            205,
            206,
            209,
            210
          ],
          "missing_lines": []
        },
        "calculate_cyclomatic_complexity_for_module": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 2,
          "lines": 2,
          "covered_lines": [
            225,
            231
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "pydocstyle": {
          "functions": {
            "ComplexityVisitor": [
              {
                "code": "D205",
                "message": "1 blank line required between summary line and description (found 0)"
              }
            ],
            "__init__": [
              {
                "code": "D205",
                "message": "1 blank line required between summary line and description (found 0)"
              }
            ],
            "calculate_function_complexity_map": [
              {
                "code": "D205",
                "message": "1 blank line required between summary line and description (found 0)"
              }
            ]
          }
        }
      }
    }
  },
  "refactor/complexity/complexity_summary.py": {
    "docstrings": {
      "module_doc": {
        "description": "complexity_summary.py\nThis module provides functionality for analyzing code complexity from a JSON audit file.\nIt reads the audit data, checks for complexity thresholds, and prints a summary report\nindicating any methods that exceed the specified complexity limits.\nDependencies:\n- json\n- sys\n- os",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "analyze_complexity",
          "description": "Analyzes code complexity from a JSON audit file and prints a summary.\nParameters:\nfile_path (str): Path to the audit JSON file. Defaults to \"refactor_audit.json\".\nmax_complexity (int): Maximum allowed complexity before issuing warnings. Defaults to 10.\nExits the process with an error message if the file is missing, empty, or contains invalid JSON.",
          "args": null,
          "returns": null
        },
        {
          "name": "run_analysis",
          "description": "Analyzes method complexity across files and prints a summary report.",
          "args": "data (Dict[str, Any]): Mapping of file names to complexity information.\nmax_complexity (Union[int, float]): Threshold for complexity warnings.\nuse_emoji (bool, optional): If True, prints summary with emojis; otherwise, uses plain text.\nPrints:\nA summary of methods and files analyzed, and lists methods exceeding the complexity threshold.\nExits the process with an error code if warnings are found and use_emoji is False.",
          "returns": null
        }
      ]
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {
        "analyze_complexity": {
          "complexity": 8,
          "coverage": 1.0,
          "hits": 20,
          "lines": 20,
          "covered_lines": [
            36,
            37,
            38,
            39,
            41,
            42,
            43,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            54,
            56,
            57,
            58
          ],
          "missing_lines": []
        },
        "run_analysis": {
          "complexity": 10,
          "coverage": 0.9787,
          "hits": 29,
          "lines": 29,
          "covered_lines": [
            76,
            77,
            79,
            80,
            81,
            82,
            83,
            84,
            85,
            86,
            88,
            89,
            90,
            91,
            93,
            94,
            95,
            96,
            97,
            99,
            101,
            102,
            103,
            105,
            106,
            107,
            108,
            109,
            111
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "mypy": {
          "errors": [
            "scripts/refactor/complexity/complexity_summary.py:21: error: Item \"TextIO\" of \"TextIO | Any\" has no attribute \"reconfigure\"  [union-attr]"
          ]
        }
      }
    }
  },
  "refactor/compressor/__init__.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": []
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {}
    },
    "linting": {}
  },
  "refactor/compressor/merged_report_squeezer.py": {
    "docstrings": {
      "module_doc": {
        "description": "merged_report_squeezer.py\n================================\nBespoke *lossless* compressor / decompressor for the **merged_report.json**\nartifact produced by the CIaudit pipeline.\nThe original file is 450kB of JSON, but 60% of that is the repetitive\ntriplet:\n```jsonc\n{\"description\": \"\", \"args\": \"\", \"returns\": \"\"}\n```\nThat exact structure appears for every module docstring, every class\ndocstring, every function docstring hundreds of times.  Hoisting each\n*unique* triplet into a single lookup table and replacing the objects with a\nsmall integer ID cuts the raw size to 90kB.  A `gzip -9` on top drives the\nfile under 12kB.\n-----------------------------------------------------------------------\nCompression model\n-----------------------------------------------------------------------\n```text\nroot\n \"doc\"    list[ [descr, args, returns] ]        (lookuptable)\n \"files\"  dict[str, dict]  # key = file path\n \"d\"  docstrings block                     (see below)\n \"cov\"  coverage        (verbatim)\n \"lint\"  linting/errors  (verbatim)\n# \"d\" layout (all keys are *oneletter* to save space)\n{\n\"m\": <id or null>,                    # module docstring\n\"c\": [ [class_name, id],  ],         # class docs\n\"f\": [ [func_name, id],   ]          # function docs\n}\n```\nThe compressor is *bespoke*: it knows exactly which parts to shrink and which\nones (coverage & linting) to copy wholesale.\n-----------------------------------------------------------------------\nPublic API\n-----------------------------------------------------------------------\n```\ncompress_obj(orig: dict) -> dict  # shrunken structure\ncompress(path_in, path_out)       # CLI helper\ndecompress_obj(blob: dict) -> dict  # original structure\n```\n-----------------------------------------------------------------------\nCLI usage\n-----------------------------------------------------------------------\n```bash\n# shrink\npython merged_report_squeezer.py compress merged_report.json merged_report.comp.json\n# expand (roundtrip)\npython merged_report_squeezer.py decompress merged_report.comp.json merged_report.round.json\n# quick selftest (compressdecompress in RAM)  exits 0 on success\npython merged_report_squeezer.py selftest merged_report.json\n```\n-----------------------------------------------------------------------",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "_get_or_add",
          "description": "Return ID for *triple*; create a new one if unseen.",
          "args": null,
          "returns": null
        },
        {
          "name": "_calc_percent",
          "description": "Return overall file-coverage percentage if the *complexity* section\nprovides enough data, otherwise None.",
          "args": null,
          "returns": null
        },
        {
          "name": "compress_obj",
          "description": "Return a *compact* structure with docstrings hoisted into a lookup table.\nParameters\n----------\noriginal\nThe fullfidelity merged_report dict loaded from JSON.\nretain_keys\nIf True, keep verbose dict keys inside each docstring record instead of\npositional arrays.  (Adds ~2kB gzipped  handy for debugging.)",
          "args": null,
          "returns": null
        },
        {
          "name": "decompress_obj",
          "description": "Rebuild the full merged_report structure from the compact *blob*.",
          "args": null,
          "returns": null
        },
        {
          "name": "_expand",
          "description": null,
          "args": null,
          "returns": null
        },
        {
          "name": "_load_json",
          "description": null,
          "args": null,
          "returns": null
        },
        {
          "name": "_dump_json",
          "description": null,
          "args": null,
          "returns": null
        },
        {
          "name": "_cli",
          "description": null,
          "args": null,
          "returns": null
        }
      ]
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {
        "_get_or_add": {
          "complexity": 2,
          "coverage": 0.0,
          "hits": 0,
          "lines": 4,
          "covered_lines": [],
          "missing_lines": []
        },
        "_calc_percent": {
          "complexity": 3,
          "coverage": 0.0,
          "hits": 0,
          "lines": 8,
          "covered_lines": [],
          "missing_lines": []
        },
        "compress_obj": {
          "complexity": 8,
          "coverage": 0.0,
          "hits": 0,
          "lines": 30,
          "covered_lines": [],
          "missing_lines": []
        },
        "decompress_obj": {
          "complexity": 6,
          "coverage": 0.0,
          "hits": 0,
          "lines": 10,
          "covered_lines": [],
          "missing_lines": []
        },
        "_load_json": {
          "complexity": 2,
          "coverage": 0.0,
          "hits": 0,
          "lines": 4,
          "covered_lines": [],
          "missing_lines": []
        },
        "_dump_json": {
          "complexity": 2,
          "coverage": 0.0,
          "hits": 0,
          "lines": 5,
          "covered_lines": [],
          "missing_lines": []
        },
        "_cli": {
          "complexity": 8,
          "coverage": 0.0,
          "hits": 0,
          "lines": 45,
          "covered_lines": [],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "mypy": {
          "errors": [
            "scripts/refactor/compressor/merged_report_squeezer.py:259: error: Returning Any from function declared to return \"dict[str, Any]\"  [no-any-return]"
          ]
        },
        "black": {
          "needs_formatting": true
        },
        "pydocstyle": {
          "functions": {
            "_calc_percent": [
              {
                "code": "D205",
                "message": "1 blank line required between summary line and description (found 0)"
              }
            ]
          }
        }
      }
    }
  },
  "refactor/compressor/strictness_loader.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "_read",
          "description": null,
          "args": null,
          "returns": null
        },
        {
          "name": "load",
          "description": "Load *compressed* strictness JSON and return the original structure.",
          "args": null,
          "returns": null
        },
        {
          "name": "to_dataframe",
          "description": "Return a DataFrame with one row per test case (ready for Streamlit).",
          "args": null,
          "returns": null
        }
      ]
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {
        "_read": {
          "complexity": 2,
          "coverage": 0.0,
          "hits": 0,
          "lines": 4,
          "covered_lines": [],
          "missing_lines": []
        },
        "load": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 1,
          "covered_lines": [],
          "missing_lines": []
        },
        "to_dataframe": {
          "complexity": 7,
          "coverage": 0.0,
          "hits": 0,
          "lines": 8,
          "covered_lines": [],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "mypy": {
          "errors": [
            "scripts/refactor/compressor/strictness_loader.py:11: error: Returning Any from function declared to return \"dict[str, Any]\"  [no-any-return]"
          ]
        },
        "black": {
          "needs_formatting": true
        }
      }
    }
  },
  "refactor/compressor/strictness_squeezer.py": {
    "docstrings": {
      "module_doc": {
        "description": "strictness_squeezer.py\n================================\nBespoke *lossless* compressor / decompressor for the\n`strictness_mapping.json` report produced by the strictnessanalyser.\nChanges (20250509)\n--------------------\n* **Optional fields handled**  `prod_code_complexity` and\n`severity_score` are not guaranteed to be present in every test entry.\nThey are now treated as optional (stored as `None` if absent and omitted\non decompression when `None`).\nCLI\n---\n```bash\npython strictness_squeezer.py compress    <in.json> <out.json>\npython strictness_squeezer.py decompress  <in.json> <out.json>\npython strictness_squeezer.py selftest    <in.json>\n```\nStandardlibraryonly; no external deps.",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "_ensure_idx",
          "description": "Return existing index of *item* in *lst* or append and return new one.",
          "args": null,
          "returns": null
        },
        {
          "name": "compress_obj",
          "description": "Return the compact representation of **strictness_mapping.json**.",
          "args": null,
          "returns": null
        },
        {
          "name": "_fid",
          "description": null,
          "args": null,
          "returns": null
        },
        {
          "name": "_mid",
          "description": null,
          "args": null,
          "returns": null
        },
        {
          "name": "decompress_obj",
          "description": null,
          "args": null,
          "returns": null
        },
        {
          "name": "_method_from_id",
          "description": null,
          "args": null,
          "returns": null
        },
        {
          "name": "_cli",
          "description": null,
          "args": null,
          "returns": null
        }
      ]
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {
        "_ensure_idx": {
          "complexity": 3,
          "coverage": 0.0,
          "hits": 0,
          "lines": 7,
          "covered_lines": [],
          "missing_lines": []
        },
        "compress_obj": {
          "complexity": 6,
          "coverage": 0.0,
          "hits": 0,
          "lines": 12,
          "covered_lines": [],
          "missing_lines": []
        },
        "decompress_obj": {
          "complexity": 8,
          "coverage": 0.0,
          "hits": 0,
          "lines": 13,
          "covered_lines": [],
          "missing_lines": []
        },
        "_cli": {
          "complexity": 5,
          "coverage": 0.0,
          "hits": 0,
          "lines": 27,
          "covered_lines": [],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "mypy": {
          "errors": [
            "scripts/refactor/compressor/strictness_squeezer.py:53: error: Missing type parameters for generic type \"Tuple\"  [type-arg]",
            "scripts/refactor/compressor/strictness_squeezer.py:54: error: Missing type parameters for generic type \"Tuple\"  [type-arg]",
            "scripts/refactor/compressor/strictness_squeezer.py:63: error: Argument 1 to \"append\" of \"list\" has incompatible type \"list[Any]\"; expected \"tuple[Any, ...]\"  [arg-type]"
          ]
        },
        "black": {
          "needs_formatting": true
        },
        "pydocstyle": {
          "functions": {
            "decompress_obj": [
              {
                "code": "D103",
                "message": "Missing docstring in public function"
              }
            ]
          }
        }
      }
    }
  },
  "refactor/lint_report_pkg/__init__.py": {
    "docstrings": {
      "module_doc": {
        "description": "Plugin-based quality-checker package.\n`core.merge_into_refactor_guard()` is the only public entry-point most\ncode ever needs.",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "register",
          "description": "Decorator used by each plugin module to register it in the plugin registry.",
          "args": "name (str): The name to register the plugin under.",
          "returns": "Callable[[Type], Type]: A decorator that registers the class in the plugin registry."
        },
        {
          "name": "_inner",
          "description": null,
          "args": null,
          "returns": null
        },
        {
          "name": "_discover_plugins",
          "description": "Discovers and imports all plugin modules in the 'plugins' directory.\nThis function automatically imports all Python files in the 'plugins' directory,\nexcluding those that start with an underscore.",
          "args": null,
          "returns": null
        }
      ]
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {
        "register": {
          "complexity": 1,
          "coverage": 0.3125,
          "hits": 5,
          "lines": 16,
          "covered_lines": [],
          "missing_lines": [
            15,
            16,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27
          ]
        },
        "_discover_plugins": {
          "complexity": 3,
          "coverage": 0.4167,
          "hits": 5,
          "lines": 12,
          "covered_lines": [],
          "missing_lines": [
            33,
            37,
            38,
            39,
            42,
            43,
            44
          ]
        }
      }
    },
    "linting": {
      "quality": {
        "flake8": {
          "issues": [
            {
              "line": 12,
              "column": 29,
              "code": "F821",
              "message": "undefined name 'ToolPlugin'"
            },
            {
              "line": 49,
              "column": 1,
              "code": "F401",
              "message": "'.quality_checker.merge_into_refactor_guard' imported but unused"
            },
            {
              "line": 49,
              "column": 1,
              "code": "F401",
              "message": "'.quality_checker.merge_reports' imported but unused"
            },
            {
              "line": 12,
              "column": 29,
              "code": "F821",
              "message": "undefined name 'ToolPlugin'"
            }
          ]
        },
        "mypy": {
          "errors": [
            "scripts/refactor/lint_report_pkg/__init__.py:12: error: Name \"ToolPlugin\" is not defined  [name-defined]",
            "scripts/refactor/lint_report_pkg/__init__.py:15: error: Missing type parameters for generic type \"Type\"  [type-arg]",
            "scripts/refactor/lint_report_pkg/__init__.py:26: error: Missing type parameters for generic type \"Type\"  [type-arg]"
          ]
        },
        "coverage": {
          "percent": 58.8
        }
      }
    }
  },
  "refactor/lint_report_pkg/core.py": {
    "docstrings": {
      "module_doc": {
        "description": "Core Module for Lint Report Package\n=====================================\nThis module provides the base class for tool plugins and functions for plugin discovery.\nIt includes the abstract base class ToolPlugin that all plugins must implement,\nand a utility to access all discovered plugins.",
        "args": null,
        "returns": null
      },
      "classes": [
        {
          "name": "ToolPlugin",
          "description": "Abstract base class for tool plugins.\nAll subclasses must define:\n- name: str (unique plugin name)\n- default_report: Path (where output is written)\n- run(): run the tool\n- parse(dst): enrich the lint result dictionary",
          "args": null,
          "returns": null
        }
      ],
      "functions": [
        {
          "name": "name",
          "description": "Unique plugin identifier (e.g., 'flake8').",
          "args": null,
          "returns": null
        },
        {
          "name": "default_report",
          "description": "Path where the tool writes its report (txt/json/xml).",
          "args": null,
          "returns": null
        },
        {
          "name": "run",
          "description": "Execute the tool, writing to `default_report`; return exit code.",
          "args": null,
          "returns": null
        },
        {
          "name": "parse",
          "description": "Read `default_report` and update `dst` with findings.",
          "args": null,
          "returns": null
        },
        {
          "name": "all_plugins",
          "description": "Return all ToolPlugin instances registered by plugin modules.",
          "args": null,
          "returns": null
        }
      ]
    },
    "coverage": {
      "method_diff": {
        "ToolPlugin": {
          "missing": [],
          "added": [
            "name",
            "default_report",
            "run",
            "parse"
          ]
        }
      },
      "missing_tests": [],
      "complexity": {
        "ToolPlugin.name": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 1,
          "covered_lines": [],
          "missing_lines": []
        },
        "ToolPlugin.default_report": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 1,
          "covered_lines": [],
          "missing_lines": []
        },
        "ToolPlugin.run": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 1,
          "covered_lines": [],
          "missing_lines": []
        },
        "ToolPlugin.parse": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 1,
          "covered_lines": [],
          "missing_lines": []
        },
        "all_plugins": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 1,
          "lines": 1,
          "covered_lines": [
            59
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "flake8": {
          "issues": [
            {
              "line": 17,
              "column": 1,
              "code": "E302",
              "message": "expected 2 blank lines, found 1"
            }
          ]
        },
        "black": {
          "needs_formatting": true
        },
        "pydocstyle": {
          "functions": {
            "all_plugins": [
              {
                "code": "D200",
                "message": "One-line docstring should fit on one line with quotes (found 3)"
              }
            ]
          }
        },
        "coverage": {
          "percent": 81.8
        }
      }
    }
  },
  "refactor/lint_report_pkg/helpers.py": {
    "docstrings": {
      "module_doc": {
        "description": "Helpers for Lint Report Package\n===============================\nThis module provides utility functions shared by the quality-checker core and plugins.\nIt includes functions for running commands, printing safely, and reading report files.",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "safe_print",
          "description": "Print `msg` even on exotic console encodings (swallows UnicodeEncodeError).",
          "args": "msg (str): The message to print.",
          "returns": null
        },
        {
          "name": "run_cmd",
          "description": "Run *cmd*, write **combined stdout + stderr** to *output_file* (UTF-8),\nand return the subprocess' exit-code.",
          "args": "cmd (Sequence[str]): The command to run.\noutput_file (Union[str, os.PathLike]): The file to write the output to.",
          "returns": "int: The exit code of the command."
        },
        {
          "name": "read_report",
          "description": "Return the textual contents of *path* (empty string if the file is missing),\ndecoding as UTF-8 and falling back to replace for any bad bytes.",
          "args": "path (Path): The path to the report file.",
          "returns": "str: The contents of the report file."
        }
      ]
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {
        "safe_print": {
          "complexity": 3,
          "coverage": 0.5,
          "hits": 2,
          "lines": 4,
          "covered_lines": [
            27,
            28
          ],
          "missing_lines": []
        },
        "run_cmd": {
          "complexity": 2,
          "coverage": 1.0,
          "hits": 3,
          "lines": 3,
          "covered_lines": [
            48,
            49,
            53
          ],
          "missing_lines": []
        },
        "read_report": {
          "complexity": 4,
          "coverage": 0.5,
          "hits": 3,
          "lines": 6,
          "covered_lines": [
            70,
            72,
            73
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "mypy": {
          "errors": [
            "scripts/refactor/lint_report_pkg/helpers.py:36: error: Missing type parameters for generic type \"PathLike\"  [type-arg]"
          ]
        },
        "pydocstyle": {
          "functions": {
            "run_cmd": [
              {
                "code": "D205",
                "message": "1 blank line required between summary line and description (found 0)"
              }
            ],
            "read_report": [
              {
                "code": "D205",
                "message": "1 blank line required between summary line and description (found 0)"
              }
            ]
          }
        }
      }
    }
  },
  "refactor/lint_report_pkg/lint_report_cli.py": {
    "docstrings": {
      "module_doc": {
        "description": "Lint Report CLI\n===============================\nThis script enriches a RefactorGuard audit file with linting, coverage, and docstring analysis data.\nKey points:\n- Zero-setup: If the audit JSON is missing, an empty one is created for plugins to populate.\n- No --reports argument: Each plugin runs its own tool and saves its report next to the audit file.\n- Optional docstring merge: If a docstring summary JSON is present, it is injected under a top-level \"docstrings\" key in the audit file.\nTypical usage:\n$ python lint_report_cli.py --audit refactor_audit.json\n$ python lint_report_cli.py --audit refactor_audit.json --docstrings docstring_summary.json",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "enrich_refactor_audit",
          "description": "Enrich *audit_path* with lint, coverage, and optional docstring data.\nParameters:\n----------\naudit_path: str\nPath to the RefactorGuard audit JSON file.",
          "args": null,
          "returns": null
        }
      ]
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {
        "enrich_refactor_audit": {
          "complexity": 2,
          "coverage": 0.6667,
          "hits": 5,
          "lines": 7,
          "covered_lines": [
            41,
            46,
            53,
            54,
            55
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "flake8": {
          "issues": [
            {
              "line": 19,
              "column": 1,
              "code": "F401",
              "message": "'json' imported but unused"
            },
            {
              "line": 32,
              "column": 1,
              "code": "E302",
              "message": "expected 2 blank lines, found 1"
            },
            {
              "line": 73,
              "column": 5,
              "code": "E303",
              "message": "too many blank lines (2)"
            },
            {
              "line": 19,
              "column": 1,
              "code": "F401",
              "message": "'json' imported but unused"
            },
            {
              "line": 32,
              "column": 1,
              "code": "E302",
              "message": "expected 2 blank lines, found 1"
            },
            {
              "line": 73,
              "column": 5,
              "code": "E303",
              "message": "too many blank lines (2)"
            }
          ]
        },
        "mypy": {
          "errors": [
            "scripts/refactor/lint_report_pkg/lint_report_cli.py:27: error: Unused \"type: ignore\" comment  [unused-ignore]",
            "scripts/refactor/lint_report_pkg/lint_report_cli.py:28: error: Unused \"type: ignore\" comment  [unused-ignore]"
          ]
        },
        "black": {
          "needs_formatting": true
        },
        "coverage": {
          "percent": 0.0
        }
      }
    }
  },
  "refactor/lint_report_pkg/path_utils.py": {
    "docstrings": {
      "module_doc": {
        "description": "Path Utilities for Quality Audit Modules\n===============================\nThis module provides common path helper functions used across quality and audit modules.\nIt includes functions for normalizing paths relative to the repository root.",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "norm",
          "description": "Return a *repository-relative* normalized path.\nIf the file lives outside the repo, fall back to last-two components\nto avoid collisions yet stay platform-agnostic.",
          "args": "p (str | os.PathLike): The path to normalize.",
          "returns": "str: The normalized repository-relative path."
        }
      ]
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {
        "norm": {
          "complexity": 3,
          "coverage": 1.0,
          "hits": 5,
          "lines": 5,
          "covered_lines": [
            29,
            30,
            31,
            32,
            33
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "mypy": {
          "errors": [
            "scripts/refactor/lint_report_pkg/path_utils.py:16: error: Missing type parameters for generic type \"PathLike\"  [type-arg]"
          ]
        }
      }
    }
  },
  "refactor/lint_report_pkg/plugins/__init__.py": {
    "docstrings": {
      "module_doc": {
        "description": "Auto-discover all ToolPlugin subclasses so the orchestrator can `import PLUGINS`.",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": []
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {}
    },
    "linting": {
      "quality": {
        "black": {
          "needs_formatting": true
        }
      }
    }
  },
  "refactor/lint_report_pkg/plugins/black.py": {
    "docstrings": {
      "module_doc": {
        "description": "Black Plugin for Lint Report Package\n===============================\nThis module provides a plugin for the Black code formatter, implementing the ToolPlugin interface.\nIt includes functionality to run Black on code and parse its output for formatting issues.",
        "args": null,
        "returns": null
      },
      "classes": [
        {
          "name": "BlackPlugin",
          "description": "Plugin for the Black code formatter.\nAttributes:\nname (str): The name of the plugin.\ndefault_report (Path): The default report file path.",
          "args": null,
          "returns": null
        }
      ],
      "functions": [
        {
          "name": "run",
          "description": "Run Black in check mode on the scripts directory.",
          "args": null,
          "returns": "int: The exit code from the Black command."
        },
        {
          "name": "parse",
          "description": "Parse the output report from Black and update the destination dictionary.",
          "args": "dst (Dict[str, Dict[str, Any]]): Destination dictionary to update with formatting needs.",
          "returns": null
        }
      ]
    },
    "coverage": {
      "method_diff": {
        "BlackPlugin": {
          "missing": [],
          "added": [
            "run",
            "parse"
          ]
        }
      },
      "missing_tests": [],
      "complexity": {
        "BlackPlugin.run": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 1,
          "covered_lines": [],
          "missing_lines": []
        },
        "BlackPlugin.parse": {
          "complexity": 3,
          "coverage": 1.0,
          "hits": 4,
          "lines": 4,
          "covered_lines": [
            44,
            45,
            46,
            47
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "black": {
          "needs_formatting": true
        }
      }
    }
  },
  "refactor/lint_report_pkg/plugins/coverage_plugin.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [
        {
          "name": "CoveragePlugin",
          "description": null,
          "args": null,
          "returns": null
        }
      ],
      "functions": [
        {
          "name": "run",
          "description": null,
          "args": null,
          "returns": null
        },
        {
          "name": "parse",
          "description": null,
          "args": null,
          "returns": null
        }
      ]
    },
    "coverage": {
      "method_diff": {
        "CoveragePlugin": {
          "missing": [],
          "added": [
            "run",
            "parse"
          ]
        }
      },
      "missing_tests": [],
      "complexity": {
        "CoveragePlugin.run": {
          "complexity": 2,
          "coverage": 0.5,
          "hits": 2,
          "lines": 4,
          "covered_lines": [
            27,
            30
          ],
          "missing_lines": []
        },
        "CoveragePlugin.parse": {
          "complexity": 11,
          "coverage": 0.5,
          "hits": 13,
          "lines": 26,
          "covered_lines": [
            33,
            36,
            50,
            51,
            52,
            53,
            54,
            56,
            57,
            58,
            59,
            60,
            61
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "flake8": {
          "issues": [
            {
              "line": 9,
              "column": 1,
              "code": "F401",
              "message": "'math' imported but unused"
            },
            {
              "line": 10,
              "column": 1,
              "code": "F401",
              "message": "'json' imported but unused"
            },
            {
              "line": 40,
              "column": 24,
              "code": "E221",
              "message": "multiple spaces before operator"
            },
            {
              "line": 41,
              "column": 25,
              "code": "E221",
              "message": "multiple spaces before operator"
            },
            {
              "line": 43,
              "column": 24,
              "code": "E221",
              "message": "multiple spaces before operator"
            },
            {
              "line": 9,
              "column": 1,
              "code": "F401",
              "message": "'math' imported but unused"
            },
            {
              "line": 10,
              "column": 1,
              "code": "F401",
              "message": "'json' imported but unused"
            },
            {
              "line": 40,
              "column": 24,
              "code": "E221",
              "message": "multiple spaces before operator"
            },
            {
              "line": 41,
              "column": 25,
              "code": "E221",
              "message": "multiple spaces before operator"
            },
            {
              "line": 43,
              "column": 24,
              "code": "E221",
              "message": "multiple spaces before operator"
            }
          ]
        },
        "black": {
          "needs_formatting": true
        },
        "pydocstyle": {
          "functions": {
            "CoveragePlugin": [
              {
                "code": "D101",
                "message": "Missing docstring in public class"
              }
            ],
            "run": [
              {
                "code": "D102",
                "message": "Missing docstring in public method"
              }
            ],
            "parse": [
              {
                "code": "D102",
                "message": "Missing docstring in public method"
              }
            ]
          }
        },
        "coverage": {
          "percent": 68.1
        }
      }
    }
  },
  "refactor/lint_report_pkg/plugins/flake8.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [
        {
          "name": "Flake8Plugin",
          "description": null,
          "args": null,
          "returns": null
        }
      ],
      "functions": [
        {
          "name": "run",
          "description": null,
          "args": null,
          "returns": null
        },
        {
          "name": "parse",
          "description": null,
          "args": null,
          "returns": null
        }
      ]
    },
    "coverage": {
      "method_diff": {
        "Flake8Plugin": {
          "missing": [],
          "added": [
            "run",
            "parse"
          ]
        }
      },
      "missing_tests": [],
      "complexity": {
        "Flake8Plugin.run": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 1,
          "covered_lines": [],
          "missing_lines": []
        },
        "Flake8Plugin.parse": {
          "complexity": 5,
          "coverage": 1.0,
          "hits": 10,
          "lines": 10,
          "covered_lines": [
            27,
            28,
            33,
            34,
            35,
            36,
            37,
            38,
            39,
            40
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "flake8": {
          "issues": [
            {
              "line": 42,
              "column": 5,
              "code": "E303",
              "message": "too many blank lines (2)"
            }
          ]
        },
        "black": {
          "needs_formatting": true
        },
        "pydocstyle": {
          "functions": {
            "Flake8Plugin": [
              {
                "code": "D101",
                "message": "Missing docstring in public class"
              }
            ],
            "run": [
              {
                "code": "D102",
                "message": "Missing docstring in public method"
              }
            ],
            "parse": [
              {
                "code": "D102",
                "message": "Missing docstring in public method"
              }
            ]
          }
        },
        "coverage": {
          "percent": 95.8
        }
      }
    }
  },
  "refactor/lint_report_pkg/plugins/mypy.py": {
    "docstrings": {
      "module_doc": {
        "description": "Mypy Plugin for Lint Report Package\n===============================\nThis module provides a plugin for the MyPy type checker, implementing the ToolPlugin interface.\nIt includes functionality to run MyPy on code and parse its output for type checking errors.",
        "args": null,
        "returns": null
      },
      "classes": [
        {
          "name": "MypyPlugin",
          "description": "Plugin for the MyPy type checker.\nAttributes:\nname (str): The name of the plugin.\ndefault_report (Path): The default report file path.",
          "args": null,
          "returns": null
        }
      ],
      "functions": [
        {
          "name": "run",
          "description": "Run MyPy in strict mode on the scripts directory.",
          "args": null,
          "returns": "int: The exit code from the MyPy command."
        },
        {
          "name": "parse",
          "description": "Parse the output report from MyPy and update the destination dictionary.",
          "args": "dst (Dict[str, Dict[str, Any]]): Destination dictionary to update with type checking errors.",
          "returns": null
        }
      ]
    },
    "coverage": {
      "method_diff": {
        "MypyPlugin": {
          "missing": [],
          "added": [
            "run",
            "parse"
          ]
        }
      },
      "missing_tests": [],
      "complexity": {
        "MypyPlugin.run": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 1,
          "covered_lines": [],
          "missing_lines": []
        },
        "MypyPlugin.parse": {
          "complexity": 4,
          "coverage": 1.0,
          "hits": 5,
          "lines": 5,
          "covered_lines": [
            45,
            46,
            47,
            48,
            49
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "black": {
          "needs_formatting": true
        }
      }
    }
  },
  "refactor/lint_report_pkg/plugins/pydocstyle.py": {
    "docstrings": {
      "module_doc": {
        "description": "Pydocstyle Plugin for Lint Report Package\n===============================\nThis module provides a plugin for the pydocstyle tool, implementing the ToolPlugin interface.\nIt includes functionality to run pydocstyle on code and parse its output for docstring issues.",
        "args": null,
        "returns": null
      },
      "classes": [
        {
          "name": "PydocstylePlugin",
          "description": "Plugin for the pydocstyle tool.\nAttributes:\nname (str): The name of the plugin.\ndefault_report (Path): The default report file path.",
          "args": null,
          "returns": null
        }
      ],
      "functions": [
        {
          "name": "run",
          "description": "Execute the pydocstyle tool on the scripts directory.",
          "args": null,
          "returns": "int: The exit code from the pydocstyle command."
        },
        {
          "name": "parse",
          "description": "Parse pydocstyle output and inject docstring issues grouped by symbol with full detail.",
          "args": "dst (Dict[str, Dict[str, Any]]): Destination dictionary to update with docstring issues.",
          "returns": null
        }
      ]
    },
    "coverage": {
      "method_diff": {
        "PydocstylePlugin": {
          "missing": [],
          "added": [
            "run",
            "parse"
          ]
        }
      },
      "missing_tests": [],
      "complexity": {
        "PydocstylePlugin.run": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 1,
          "covered_lines": [],
          "missing_lines": []
        },
        "PydocstylePlugin.parse": {
          "complexity": 6,
          "coverage": 0.8182,
          "hits": 14,
          "lines": 16,
          "covered_lines": [
            49,
            50,
            52,
            54,
            55,
            59,
            62,
            63,
            64,
            66,
            67,
            70,
            72,
            73
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "flake8": {
          "issues": [
            {
              "line": 17,
              "column": 1,
              "code": "F401",
              "message": "'collections.defaultdict' imported but unused"
            },
            {
              "line": 17,
              "column": 1,
              "code": "F401",
              "message": "'collections.defaultdict' imported but unused"
            }
          ]
        },
        "black": {
          "needs_formatting": true
        },
        "coverage": {
          "percent": 89.7
        }
      }
    }
  },
  "refactor/lint_report_pkg/quality_checker.py": {
    "docstrings": {
      "module_doc": {
        "description": "Quality Checker for Lint Report Package\n=======================================\nThis module serves as the public API for the lint report package.\nIt imports all plugins, drives tool execution and parsing, and merges results into the RefactorGuard audit.",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "merge_into_refactor_guard",
          "description": "Enrich *audit_path* with quality data produced by every plugin.\nParameters\n----------\naudit_path : str\nPath to the RefactorGuard audit JSON file.",
          "args": null,
          "returns": null
        },
        {
          "name": "merge_reports",
          "description": "Return merged dict where *b* overrides *a* on duplicate keys.\nParameters\n----------\nfile_a : str\nPath to the first JSON file.\nfile_b : str\nPath to the second JSON file.",
          "args": null,
          "returns": null
        }
      ]
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {
        "merge_into_refactor_guard": {
          "complexity": 16,
          "coverage": 0.8478,
          "hits": 28,
          "lines": 34,
          "covered_lines": [
            29,
            32,
            36,
            37,
            43,
            44,
            45,
            46,
            49,
            50,
            51,
            53,
            54,
            55,
            56,
            57,
            59,
            60,
            63,
            64,
            68,
            71,
            72,
            75,
            76,
            79,
            80,
            81
          ],
          "missing_lines": []
        },
        "merge_reports": {
          "complexity": 3,
          "coverage": 0.0,
          "hits": 0,
          "lines": 5,
          "covered_lines": [],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "mypy": {
          "errors": [
            "scripts/refactor/lint_report_pkg/quality_checker.py:51: error: Property \"default_report\" defined in \"ToolPlugin\" is read-only  [misc]"
          ]
        },
        "black": {
          "needs_formatting": true
        }
      }
    }
  },
  "refactor/lint_report_pkg/quality_registry.py": {
    "docstrings": {
      "module_doc": {
        "description": "Quality Registry for Lint Report Package\n===============================\nThis module provides functionality to register and run quality plugins.\nIt includes decorators for registering plugins and a method to invoke all registered plugins.",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "register",
          "description": "Decorator to register a quality plug-in.",
          "args": "func (Plugin): The plugin function to register.",
          "returns": "Plugin: The registered plugin function."
        },
        {
          "name": "run_all",
          "description": "Invoke every registered plug-in in order.",
          "args": "quality (Dict[str, Dict[str, Any]]): The quality data to pass to plugins.\nreport_paths (Dict[str, Path]): The paths to the reports.",
          "returns": null
        }
      ]
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {
        "register": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 2,
          "covered_lines": [],
          "missing_lines": []
        },
        "run_all": {
          "complexity": 2,
          "coverage": 0.0,
          "hits": 0,
          "lines": 2,
          "covered_lines": [],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "coverage": {
          "percent": 0.0
        }
      }
    }
  },
  "refactor/merge_audit_reports.py": {
    "docstrings": {
      "module_doc": {
        "description": "merge_audit_reports.py  bespoke normalizer\nMerges docstring, coverage/complexity, and linting JSON reports into a unified output.\nUses **custom normalization logic per input source** to ensure accurate matching.\nAuthor: Your Name\nVersion: 1.0",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "normalize_path",
          "description": "Normalize any report path by stripping everything up to and including the project 'scripts' directory\nand converting to a forwardslash relative path.",
          "args": "path (str): The original file path.",
          "returns": "str: The normalized relative path."
        },
        {
          "name": "load_and_normalize",
          "description": "Load JSON and normalize its keys using a common path normalizer.",
          "args": "path (Path): The path to the JSON file.",
          "returns": "Dict[str, Any]: A dictionary with normalized keys and their corresponding values."
        },
        {
          "name": "merge_reports",
          "description": "Merge docstring, coverage, and linting reports into a single JSON output.",
          "args": "doc_path (Path): Path to the docstring JSON file.\ncov_path (Path): Path to the coverage JSON file.\nlint_path (Path): Path to the linting JSON file.\noutput_path (Path): Path where the merged output will be saved.",
          "returns": null
        },
        {
          "name": "main",
          "description": "Main entry point for the script.",
          "args": null,
          "returns": null
        }
      ]
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {
        "normalize_path": {
          "complexity": 3,
          "coverage": 1.0,
          "hits": 8,
          "lines": 8,
          "covered_lines": [
            30,
            31,
            32,
            33,
            34,
            35,
            37,
            39
          ],
          "missing_lines": []
        },
        "load_and_normalize": {
          "complexity": 4,
          "coverage": 1.0,
          "hits": 3,
          "lines": 3,
          "covered_lines": [
            52,
            53,
            54
          ],
          "missing_lines": []
        },
        "merge_reports": {
          "complexity": 2,
          "coverage": 1.0,
          "hits": 9,
          "lines": 9,
          "covered_lines": [
            67,
            68,
            69,
            71,
            72,
            74,
            75,
            81,
            82
          ],
          "missing_lines": []
        },
        "main": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 7,
          "covered_lines": [],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "black": {
          "needs_formatting": true
        },
        "pydocstyle": {
          "functions": {
            "normalize_path": [
              {
                "code": "D205",
                "message": "1 blank line required between summary line and description (found 0)"
              }
            ],
            "main": [
              {
                "code": "D200",
                "message": "One-line docstring should fit on one line with quotes (found 3)"
              }
            ]
          }
        }
      }
    }
  },
  "refactor/method_line_ranges.py": {
    "docstrings": {
      "module_doc": {
        "description": "method_line_ranges.py\nThis module provides utilities for extracting the start and end line numbers of all functions and methods in a Python source file using the AST (Abstract Syntax Tree).\nCore features include:\n- The MethodRangeVisitor class, which traverses the AST to collect line ranges for top-level functions, class methods, and methods in nested classes.\n- The extract_method_line_ranges function, which parses a Python file and returns a dictionary mapping each function or method (as \"function\" or \"Class.method\") to its (start_lineno, end_lineno) tuple.\n- Handles both synchronous and asynchronous functions, and supports Python versions with or without the end_lineno attribute.\n- Designed for use in code analysis, refactoring tools, and coverage mapping.\nIntended to facilitate precise mapping of code structure for downstream analysis and tooling.",
        "args": null,
        "returns": null
      },
      "classes": [
        {
          "name": "MethodRangeVisitor",
          "description": "Collects start and end line numbers for each function or async method,\nkeyed by 'ClassName.method' for methods or just 'function' for top-level functions.\nNested classes are also visited.\nAttributes:\nranges (Dict[str, Tuple[int, int]]): A dictionary mapping functions or methods to their line ranges.\ncurrent_class (Optional[str]): The name of the current class being visited.",
          "args": null,
          "returns": null
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "description": "Initializes the MethodRangeVisitor with an empty dictionary for ranges\nand a placeholder for the current class name.",
          "args": null,
          "returns": null
        },
        {
          "name": "visit_ClassDef",
          "description": "Visits a class definition node and collects line ranges for its methods.",
          "args": "node (ast.ClassDef): The class definition node to visit.",
          "returns": null
        },
        {
          "name": "visit_FunctionDef",
          "description": "Visits a function definition node and records its line range.",
          "args": "node (ast.FunctionDef): The function definition node to visit.",
          "returns": null
        },
        {
          "name": "visit_AsyncFunctionDef",
          "description": "Visits an asynchronous function definition node and records its line range.",
          "args": "node (ast.AsyncFunctionDef): The asynchronous function definition node to visit.",
          "returns": null
        },
        {
          "name": "_record_range",
          "description": "Records the line range for a function or asynchronous function node.",
          "args": "node (Union[ast.FunctionDef, ast.AsyncFunctionDef]): The function or asynchronous function node to record.",
          "returns": null
        },
        {
          "name": "extract_method_line_ranges",
          "description": "Parses a Python file and returns a dict mapping each function or method\nto its (start_lineno, end_lineno).",
          "args": "file_path (str): Path to the Python source file.",
          "returns": "Dict[str, Tuple[int, int]]: A dict mapping functions or methods to their line ranges.\nRaises:\nFileNotFoundError: If the file cannot be found.\nIOError: If the file cannot be read.\nSyntaxError: If the file cannot be parsed."
        }
      ]
    },
    "coverage": {
      "method_diff": {
        "MethodRangeVisitor": {
          "missing": [],
          "added": [
            "__init__",
            "visit_ClassDef",
            "visit_FunctionDef",
            "visit_AsyncFunctionDef",
            "_record_range"
          ]
        }
      },
      "missing_tests": [],
      "complexity": {
        "MethodRangeVisitor.__init__": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 2,
          "lines": 2,
          "covered_lines": [
            36,
            37
          ],
          "missing_lines": []
        },
        "MethodRangeVisitor.visit_ClassDef": {
          "complexity": 5,
          "coverage": 1.0,
          "hits": 9,
          "lines": 9,
          "covered_lines": [
            46,
            47,
            50,
            51,
            52,
            55,
            56,
            57,
            59
          ],
          "missing_lines": []
        },
        "MethodRangeVisitor.visit_FunctionDef": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 1,
          "lines": 1,
          "covered_lines": [
            68
          ],
          "missing_lines": []
        },
        "MethodRangeVisitor.visit_AsyncFunctionDef": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 1,
          "lines": 1,
          "covered_lines": [
            77
          ],
          "missing_lines": []
        },
        "MethodRangeVisitor._record_range": {
          "complexity": 5,
          "coverage": 0.8333,
          "hits": 7,
          "lines": 8,
          "covered_lines": [
            87,
            89,
            90,
            93,
            94,
            96,
            97
          ],
          "missing_lines": []
        },
        "extract_method_line_ranges": {
          "complexity": 3,
          "coverage": 0.8,
          "hits": 7,
          "lines": 8,
          "covered_lines": [
            116,
            120,
            121,
            122,
            124,
            125,
            126
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "pydocstyle": {
          "functions": {
            "MethodRangeVisitor": [
              {
                "code": "D205",
                "message": "1 blank line required between summary line and description (found 0)"
              }
            ],
            "__init__": [
              {
                "code": "D205",
                "message": "1 blank line required between summary line and description (found 0)"
              }
            ],
            "extract_method_line_ranges": [
              {
                "code": "D205",
                "message": "1 blank line required between summary line and description (found 0)"
              }
            ]
          }
        }
      }
    }
  },
  "refactor/parsers/__init__.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": []
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {}
    },
    "linting": {
      "quality": {
        "coverage": {
          "percent": 100.0
        }
      }
    }
  },
  "refactor/parsers/coverage_api_parser.py": {
    "docstrings": {
      "module_doc": {
        "description": "Coverage API Parser\n===============================\nThis module provides functionality to parse coverage data from a specified path.\nIt includes methods for handling file paths and matching coverage data with requested files.",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "_canonical",
          "description": "Return the canonical path for the given path.\nParameters:\n----------\np: str | Path\nThe path to be canonicalized.",
          "args": null,
          "returns": "-------\nstr\nThe canonical path."
        },
        {
          "name": "_best_suffix_match",
          "description": "Find the best suffix match for the target path among the given candidates.\nParameters:\n----------\ntarget: str\nThe target path.\ncandidates: List[str]\nA list of candidate paths.",
          "args": null,
          "returns": "-------\nstr | None\nThe best suffix match, or None if no match is found."
        },
        {
          "name": "parse_coverage_with_api",
          "description": "Parse coverage data from the specified path and return coverage information.\nParameters:\n----------\ncoverage_path: str\nPath to the coverage data file.\nmethod_ranges: Dict[str, Tuple[int, int]]\nA dictionary mapping method names to their line ranges.\nfilepath: str\nThe path of the file for which coverage is being analyzed.",
          "args": null,
          "returns": "-------\nDict[str, Any]\nA dictionary containing coverage information for the specified file."
        }
      ]
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {
        "_canonical": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 1,
          "lines": 1,
          "covered_lines": [
            30
          ],
          "missing_lines": []
        },
        "_best_suffix_match": {
          "complexity": 5,
          "coverage": 0.2632,
          "hits": 4,
          "lines": 11,
          "covered_lines": [
            48,
            49,
            50,
            58
          ],
          "missing_lines": []
        },
        "parse_coverage_with_api": {
          "complexity": 17,
          "coverage": 0.75,
          "hits": 8,
          "lines": 10,
          "covered_lines": [
            83,
            84,
            85,
            87,
            88,
            91,
            97,
            98
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "flake8": {
          "issues": [
            {
              "line": 16,
              "column": 1,
              "code": "E302",
              "message": "expected 2 blank lines, found 1"
            },
            {
              "line": 32,
              "column": 1,
              "code": "E302",
              "message": "expected 2 blank lines, found 1"
            },
            {
              "line": 61,
              "column": 1,
              "code": "E302",
              "message": "expected 2 blank lines, found 1"
            },
            {
              "line": 16,
              "column": 1,
              "code": "E302",
              "message": "expected 2 blank lines, found 1"
            },
            {
              "line": 32,
              "column": 1,
              "code": "E302",
              "message": "expected 2 blank lines, found 1"
            },
            {
              "line": 61,
              "column": 1,
              "code": "E302",
              "message": "expected 2 blank lines, found 1"
            }
          ]
        },
        "black": {
          "needs_formatting": true
        },
        "coverage": {
          "percent": 69.0
        }
      }
    }
  },
  "refactor/parsers/coverage_parser.py": {
    "docstrings": {
      "module_doc": {
        "description": "coverage_parser.py   patched  2025-05-04\n\nUtilities for mapping **coverage-xml** line hits  per-method statistics.\nKey fixes\n~~~~~~~~~\n1.  Robust path-matching:\n considers every XML entry whose *basename* matches the source file\n picks the best candidate by shared-suffix length and inside-repo bonus\n handles mixed `\\ /` path separators.\n2.  Decorator-aware ranges:\n walks *up* from the reported `start_lineno` while preceding lines\nare also executed  so decorated functions show 100 % when hit.\n3.  No more noise from 1-liners:\n functions with fewer than ``MIN_LINES`` statements are skipped.\n4.  Pure-stdlib  no extra deps.",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "_best_xml_candidate",
          "description": "Choose the XML file path that *most* closely matches ``source``.\n Highest score = longest common suffix (# of matching path components)\n Tie-breaker: prefer a path that lives inside ``repo_root`` (if given)",
          "args": null,
          "returns": null
        },
        {
          "name": "score",
          "description": null,
          "args": null,
          "returns": null
        },
        {
          "name": "parse_coverage_xml_to_method_hits",
          "description": "Map line-level coverage (from *coverage_plugin.py* XML) to per-method statistics.\nParameters\n----------\ncoverage_xml_path\nPath to the ``coverage xml`` report that ``coverage_plugin.py`` (or pytest-cov)\nemits (usually called ``coverage.xml``).\nmethod_ranges\n``{method_name: (start_lineno, end_lineno)}``  *inclusive*\nline-number ranges extracted earlier (e.g. via `ast`).\nsource_file_path\nThe Python source file the `method_ranges` refer to.  We match only\nthe **basename** so that ``foo/bar.py`` and ``./bar.py`` both succeed.\nReturns\n-------\nDict[str, Dict[str, Any]]\n``{method_name: {\"coverage\": float, \"hits\": int, \"lines\": int}}`` \nwhere *coverage* is a ratio in [0, 1].",
          "args": null,
          "returns": null
        },
        {
          "name": "parse_coverage_to_method_hits",
          "description": "Smart wrapper that picks XML or JSON parsing automatically.",
          "args": null,
          "returns": null
        }
      ]
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {
        "_best_xml_candidate": {
          "complexity": 2,
          "coverage": 0.0,
          "hits": 0,
          "lines": 5,
          "covered_lines": [],
          "missing_lines": []
        },
        "parse_coverage_xml_to_method_hits": {
          "complexity": 19,
          "coverage": 0.878,
          "hits": 26,
          "lines": 29,
          "covered_lines": [
            100,
            101,
            103,
            104,
            105,
            106,
            108,
            110,
            113,
            114,
            115,
            118,
            119,
            122,
            123,
            124,
            125,
            128,
            129,
            131,
            134,
            135,
            137,
            138,
            139,
            141,
            147
          ],
          "missing_lines": []
        },
        "parse_coverage_to_method_hits": {
          "complexity": 2,
          "coverage": 0.0,
          "hits": 0,
          "lines": 4,
          "covered_lines": [],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "flake8": {
          "issues": [
            {
              "line": 12,
              "column": 22,
              "code": "W605",
              "message": "invalid escape sequence '/ '"
            },
            {
              "line": 27,
              "column": 1,
              "code": "F401",
              "message": "'collections.defaultdict' imported but unused"
            },
            {
              "line": 33,
              "column": 1,
              "code": "F401",
              "message": "'scripts.refactor.lint_report_pkg.path_utils.norm as normalize_path' imported but unused"
            },
            {
              "line": 105,
              "column": 5,
              "code": "F841",
              "message": "local variable 'exc' is assigned to but never used"
            },
            {
              "line": 159,
              "column": 30,
              "code": "F821",
              "message": "undefined name 'file_hits'"
            },
            {
              "line": 163,
              "column": 67,
              "code": "F821",
              "message": "undefined name 'file_hits'"
            },
            {
              "line": 12,
              "column": 22,
              "code": "W605",
              "message": "invalid escape sequence '/ '"
            },
            {
              "line": 27,
              "column": 1,
              "code": "F401",
              "message": "'collections.defaultdict' imported but unused"
            },
            {
              "line": 33,
              "column": 1,
              "code": "F401",
              "message": "'scripts.refactor.lint_report_pkg.path_utils.norm as normalize_path' imported but unused"
            },
            {
              "line": 105,
              "column": 5,
              "code": "F841",
              "message": "local variable 'exc' is assigned to but never used"
            },
            {
              "line": 159,
              "column": 30,
              "code": "F821",
              "message": "undefined name 'file_hits'"
            },
            {
              "line": 163,
              "column": 67,
              "code": "F821",
              "message": "undefined name 'file_hits'"
            }
          ]
        },
        "mypy": {
          "errors": [
            "scripts/refactor/parsers/coverage_parser.py:159: error: Name \"file_hits\" is not defined  [name-defined]",
            "scripts/refactor/parsers/coverage_parser.py:163: error: Name \"file_hits\" is not defined  [name-defined]",
            "scripts/refactor/parsers/coverage_parser.py:173: error: Function is missing a return type annotation  [no-untyped-def]",
            "scripts/refactor/parsers/coverage_parser.py:185: error: Too many positional arguments for \"parse_coverage_xml_to_method_hits\"  [misc]"
          ]
        },
        "pydocstyle": {
          "functions": {
            "parse_coverage_to_method_hits": [
              {
                "code": "D200",
                "message": "One-line docstring should fit on one line with quotes (found 3)"
              }
            ]
          }
        },
        "coverage": {
          "percent": 71.7
        }
      }
    }
  },
  "refactor/parsers/docstring_parser.py": {
    "docstrings": {
      "module_doc": {
        "description": "Docstring Parser\n===============================\nThis module scans a Python project directory for missing or partial docstrings.\nIt outputs structured JSON and markdown-style reports with description, args, and return sections.",
        "args": null,
        "returns": null
      },
      "classes": [
        {
          "name": "DocstringAnalyzer",
          "description": null,
          "args": null,
          "returns": null
        },
        {
          "name": "DocstringAuditCLI",
          "description": null,
          "args": null,
          "returns": null
        }
      ],
      "functions": [
        {
          "name": "split_docstring_sections",
          "description": "Split a docstring into its sections: description, args, and returns.",
          "args": "docstring (Optional[str]): The docstring to split.",
          "returns": "Dict[str, Optional[str]]: A dictionary containing the sections: description, args, and returns."
        },
        {
          "name": "__init__",
          "description": "Initialize the DocstringAnalyzer with directories to exclude.",
          "args": "exclude_dirs (List[str]): A list of directories to exclude from analysis.",
          "returns": null
        },
        {
          "name": "should_exclude",
          "description": "Determine if a given path should be excluded from analysis.",
          "args": "path (Path): The path to check.",
          "returns": "bool: True if the path should be excluded, False otherwise."
        },
        {
          "name": "extract_docstrings",
          "description": "Extract docstrings from a Python file, recursively.",
          "args": null,
          "returns": null
        },
        {
          "name": "visit_node",
          "description": null,
          "args": null,
          "returns": null
        },
        {
          "name": "analyze_directory",
          "description": "Analyze all Python files in the given directory and its subdirectories.",
          "args": "root (Path): The path to the directory to analyze.",
          "returns": "Dict[str, Dict[str, Any]]: A dictionary with normalized file paths as keys and\ndictionaries with docstring information as values."
        },
        {
          "name": "__init__",
          "description": "Initialize the command-line interface for the docstring audit.",
          "args": null,
          "returns": null
        },
        {
          "name": "parse_args",
          "description": "Parse command-line arguments.",
          "args": null,
          "returns": "argparse.Namespace: The parsed command-line arguments."
        },
        {
          "name": "run",
          "description": "Run the docstring audit.",
          "args": null,
          "returns": null
        }
      ]
    },
    "coverage": {
      "method_diff": {
        "DocstringAnalyzer": {
          "missing": [],
          "added": [
            "__init__",
            "should_exclude",
            "extract_docstrings",
            "analyze_directory"
          ]
        },
        "DocstringAuditCLI": {
          "missing": [],
          "added": [
            "__init__",
            "parse_args",
            "run"
          ]
        }
      },
      "missing_tests": [],
      "complexity": {
        "split_docstring_sections": {
          "complexity": 9,
          "coverage": 1.0,
          "hits": 20,
          "lines": 20,
          "covered_lines": [
            36,
            37,
            38,
            40,
            41,
            42,
            44,
            45,
            46,
            47,
            48,
            49,
            50,
            51,
            52,
            53,
            55,
            56,
            57,
            59
          ],
          "missing_lines": []
        },
        "DocstringAnalyzer.__init__": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 1,
          "lines": 1,
          "covered_lines": [
            70
          ],
          "missing_lines": []
        },
        "DocstringAnalyzer.should_exclude": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 2,
          "lines": 2,
          "covered_lines": [
            82,
            83
          ],
          "missing_lines": []
        },
        "DocstringAnalyzer.extract_docstrings": {
          "complexity": 4,
          "coverage": 0.6923,
          "hits": 8,
          "lines": 11,
          "covered_lines": [
            89,
            90,
            91,
            95,
            98,
            104,
            128,
            129
          ],
          "missing_lines": []
        },
        "DocstringAnalyzer.analyze_directory": {
          "complexity": 7,
          "coverage": 0.8667,
          "hits": 8,
          "lines": 9,
          "covered_lines": [
            142,
            143,
            144,
            145,
            146,
            149,
            150,
            152
          ],
          "missing_lines": []
        },
        "DocstringAuditCLI.__init__": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 2,
          "covered_lines": [],
          "missing_lines": []
        },
        "DocstringAuditCLI.parse_args": {
          "complexity": 1,
          "coverage": 0.0,
          "hits": 0,
          "lines": 7,
          "covered_lines": [],
          "missing_lines": []
        },
        "DocstringAuditCLI.run": {
          "complexity": 12,
          "coverage": 0.0,
          "hits": 0,
          "lines": 12,
          "covered_lines": [],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "mypy": {
          "errors": [
            "scripts/refactor/parsers/docstring_parser.py:104: error: Function is missing a type annotation  [no-untyped-def]",
            "scripts/refactor/parsers/docstring_parser.py:107: error: \"Collection[str]\" has no attribute \"append\"  [attr-defined]",
            "scripts/refactor/parsers/docstring_parser.py:117: error: \"Collection[str]\" has no attribute \"append\"  [attr-defined]",
            "scripts/refactor/parsers/docstring_parser.py:126: error: Call to untyped function \"visit_node\" in typed context  [no-untyped-call]",
            "scripts/refactor/parsers/docstring_parser.py:128: error: Call to untyped function \"visit_node\" in typed context  [no-untyped-call]"
          ]
        },
        "pydocstyle": {
          "functions": {
            "DocstringAnalyzer": [
              {
                "code": "D101",
                "message": "Missing docstring in public class"
              }
            ],
            "extract_docstrings": [
              {
                "code": "D200",
                "message": "One-line docstring should fit on one line with quotes (found 3)"
              }
            ],
            "DocstringAuditCLI": [
              {
                "code": "D101",
                "message": "Missing docstring in public class"
              }
            ],
            "__init__": [
              {
                "code": "D200",
                "message": "One-line docstring should fit on one line with quotes (found 3)"
              }
            ],
            "run": [
              {
                "code": "D200",
                "message": "One-line docstring should fit on one line with quotes (found 3)"
              }
            ]
          }
        }
      }
    }
  },
  "refactor/parsers/json_coverage_parser.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "parse_json_coverage",
          "description": "Parse JSON coverage data from the specified path and return coverage information.\nParameters\n----------\njson_path: str\nPath to the JSON coverage data file.\nmethod_ranges: Dict[str, Tuple[int, int]]\nA dictionary mapping method names to their line ranges.\nfilepath: str\nThe path of the file for which coverage is being analyzed.\nReturns\n-------\nDict[str, Any]\nA dictionary containing accurate coverage information for the specified file.",
          "args": null,
          "returns": null
        }
      ]
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {
        "parse_json_coverage": {
          "complexity": 19,
          "coverage": 0.931,
          "hits": 42,
          "lines": 44,
          "covered_lines": [
            28,
            30,
            31,
            33,
            34,
            37,
            39,
            40,
            42,
            43,
            44,
            46,
            48,
            49,
            51,
            53,
            54,
            55,
            58,
            60,
            61,
            62,
            67,
            82,
            83,
            85,
            86,
            87,
            89,
            90,
            91,
            92,
            95,
            96,
            97,
            98,
            100,
            103,
            104,
            105,
            107,
            115
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "flake8": {
          "issues": [
            {
              "line": 12,
              "column": 1,
              "code": "F401",
              "message": "'typing.List' imported but unused"
            },
            {
              "line": 12,
              "column": 1,
              "code": "F401",
              "message": "'typing.List' imported but unused"
            }
          ]
        },
        "black": {
          "needs_formatting": true
        },
        "coverage": {
          "percent": 4.2
        }
      }
    }
  },
  "refactor/refactor_guard.py": {
    "docstrings": {
      "module_doc": {
        "description": "RefactorGuard: analyse refactors and (optionally) enrich the results with linecoverage\ninformation coming from a ``.coverage`` SQLite DB or a JSON export produced by Coverage.py.\nAdds support for both `.coverage` and `coverage.json` formats. Automatically switches\nparsers based on the extension.",
        "args": null,
        "returns": null
      },
      "classes": [
        {
          "name": "AnalysisError",
          "description": "Raised when an error occurs during analysis.",
          "args": null,
          "returns": null
        },
        {
          "name": "RefactorGuard",
          "description": "Analyse / validate Python refactors.",
          "args": null,
          "returns": null
        }
      ],
      "functions": [
        {
          "name": "__init__",
          "description": null,
          "args": null,
          "returns": null
        },
        {
          "name": "attach_coverage_hits",
          "description": null,
          "args": null,
          "returns": null
        },
        {
          "name": "analyze_tests",
          "description": null,
          "args": null,
          "returns": null
        },
        {
          "name": "analyze_module",
          "description": null,
          "args": null,
          "returns": null
        },
        {
          "name": "_simple_name",
          "description": null,
          "args": null,
          "returns": null
        },
        {
          "name": "analyze_directory_recursive",
          "description": null,
          "args": null,
          "returns": null
        },
        {
          "name": "print_human_readable",
          "description": "Print a human-readable summary of the analysis results.",
          "args": null,
          "returns": null
        }
      ]
    },
    "coverage": {
      "method_diff": {
        "AnalysisError": {
          "missing": [],
          "added": []
        },
        "RefactorGuard": {
          "missing": [],
          "added": [
            "__init__",
            "attach_coverage_hits",
            "analyze_tests",
            "analyze_module",
            "analyze_directory_recursive"
          ]
        }
      },
      "missing_tests": [],
      "complexity": {
        "RefactorGuard.__init__": {
          "complexity": 2,
          "coverage": 1.0,
          "hits": 2,
          "lines": 2,
          "covered_lines": [
            37,
            43
          ],
          "missing_lines": []
        },
        "RefactorGuard.attach_coverage_hits": {
          "complexity": 3,
          "coverage": 1.0,
          "hits": 5,
          "lines": 5,
          "covered_lines": [
            46,
            47,
            48,
            49,
            50
          ],
          "missing_lines": []
        },
        "RefactorGuard.analyze_tests": {
          "complexity": 15,
          "coverage": 0.2895,
          "hits": 8,
          "lines": 24,
          "covered_lines": [
            55,
            56,
            57,
            59,
            83,
            84,
            85,
            86
          ],
          "missing_lines": []
        },
        "RefactorGuard.analyze_module": {
          "complexity": 17,
          "coverage": 0.9,
          "hits": 23,
          "lines": 26,
          "covered_lines": [
            91,
            97,
            98,
            100,
            102,
            104,
            105,
            106,
            110,
            111,
            112,
            114,
            116,
            117,
            121,
            124,
            125,
            126,
            127,
            128,
            136,
            138,
            148
          ],
          "missing_lines": []
        },
        "RefactorGuard.analyze_directory_recursive": {
          "complexity": 14,
          "coverage": 0.7551,
          "hits": 24,
          "lines": 29,
          "covered_lines": [
            153,
            154,
            155,
            157,
            158,
            159,
            163,
            164,
            166,
            167,
            170,
            171,
            172,
            175,
            176,
            177,
            178,
            179,
            181,
            182,
            183,
            184,
            186,
            188
          ],
          "missing_lines": []
        },
        "print_human_readable": {
          "complexity": 21,
          "coverage": 0.8367,
          "hits": 22,
          "lines": 23,
          "covered_lines": [
            197,
            199,
            200,
            202,
            203,
            204,
            205,
            206,
            208,
            209,
            211,
            212,
            213,
            219,
            220,
            221,
            222,
            224,
            225,
            226,
            227,
            228
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "flake8": {
          "issues": [
            {
              "line": 228,
              "column": 69,
              "code": "W292",
              "message": "no newline at end of file"
            },
            {
              "line": 228,
              "column": 69,
              "code": "W292",
              "message": "no newline at end of file"
            }
          ]
        },
        "black": {
          "needs_formatting": true
        },
        "pydocstyle": {
          "functions": {
            "__init__": [
              {
                "code": "D107",
                "message": "Missing docstring in __init__"
              }
            ],
            "attach_coverage_hits": [
              {
                "code": "D102",
                "message": "Missing docstring in public method"
              }
            ],
            "analyze_tests": [
              {
                "code": "D102",
                "message": "Missing docstring in public method"
              }
            ],
            "analyze_module": [
              {
                "code": "D102",
                "message": "Missing docstring in public method"
              }
            ],
            "analyze_directory_recursive": [
              {
                "code": "D102",
                "message": "Missing docstring in public method"
              }
            ]
          }
        },
        "coverage": {
          "percent": 80.2
        }
      }
    }
  },
  "refactor/refactor_guard_cli.py": {
    "docstrings": {
      "module_doc": {
        "description": "RefactorGuard CLI  audit Python refactors from the command line.\nCore features\n\n* directory-wide or single-file analysis\n* Git-diff-only mode\n* merge / enrich existing JSON reports\n* optional coverage integration",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "_ensure_utf8_stdout",
          "description": null,
          "args": null,
          "returns": null
        },
        {
          "name": "_parse_args",
          "description": null,
          "args": null,
          "returns": null
        },
        {
          "name": "handle_full_scan",
          "description": null,
          "args": null,
          "returns": null
        },
        {
          "name": "handle_single_file",
          "description": null,
          "args": null,
          "returns": null
        },
        {
          "name": "main",
          "description": null,
          "args": null,
          "returns": null
        }
      ]
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {
        "_ensure_utf8_stdout": {
          "complexity": 5,
          "coverage": 0.2727,
          "hits": 2,
          "lines": 7,
          "covered_lines": [
            38,
            39
          ],
          "missing_lines": []
        },
        "_parse_args": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 14,
          "lines": 14,
          "covered_lines": [
            50,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65
          ],
          "missing_lines": []
        },
        "handle_full_scan": {
          "complexity": 24,
          "coverage": 0.2099,
          "hits": 12,
          "lines": 49,
          "covered_lines": [
            69,
            70,
            71,
            73,
            76,
            86,
            88,
            89,
            90,
            91,
            93,
            124
          ],
          "missing_lines": []
        },
        "handle_single_file": {
          "complexity": 12,
          "coverage": 0.1613,
          "hits": 3,
          "lines": 21,
          "covered_lines": [
            128,
            132,
            133
          ],
          "missing_lines": []
        },
        "main": {
          "complexity": 9,
          "coverage": 0.7931,
          "hits": 16,
          "lines": 19,
          "covered_lines": [
            156,
            157,
            158,
            159,
            161,
            162,
            163,
            167,
            168,
            170,
            172,
            173,
            176,
            177,
            179,
            180
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "flake8": {
          "issues": [
            {
              "line": 22,
              "column": 1,
              "code": "F401",
              "message": "'shutil' imported but unused"
            },
            {
              "line": 22,
              "column": 1,
              "code": "F401",
              "message": "'shutil' imported but unused"
            }
          ]
        },
        "mypy": {
          "errors": [
            "scripts/refactor/refactor_guard_cli.py:163: error: Argument 1 to \"int\" has incompatible type \"str | None\"; expected \"str | Buffer | SupportsInt | SupportsIndex | SupportsTrunc\"  [arg-type]"
          ]
        },
        "black": {
          "needs_formatting": true
        },
        "pydocstyle": {
          "functions": {
            "handle_full_scan": [
              {
                "code": "D103",
                "message": "Missing docstring in public function"
              }
            ],
            "handle_single_file": [
              {
                "code": "D103",
                "message": "Missing docstring in public function"
              }
            ],
            "main": [
              {
                "code": "D103",
                "message": "Missing docstring in public function"
              }
            ]
          }
        },
        "coverage": {
          "percent": 52.3
        }
      }
    }
  },
  "refactor/strictness_analyzer.py": {
    "docstrings": {
      "module_doc": {
        "description": "Test Coverage Mapper\n===================\nThis tool maps tests to production code based on coverage data and directory structure,\nwhile also calculating test quality metrics and severity scores.\nUsage:\npython test_coverage_mapper.py --source src/ --tests tests/ --coverage coverage.json --output mapping.json\nFeatures:\n- Maps test functions to the production code they cover\n- Calculates test strictness and quality metrics\n- Integrates complexity analysis for production code\n- Produces a comprehensive report on test-to-code relationships\nAuthor: Angelos Dimakos\nVersion: 1.1.0",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "scan_test_directory",
          "description": null,
          "args": null,
          "returns": null
        },
        {
          "name": "extract_test_functions",
          "description": "Extract test function names and line ranges from a Python test file.",
          "args": "filepath (Path): The path to the Python test file.",
          "returns": "List[Dict[str, Any]]: A list of dictionaries containing test function names and their line ranges."
        },
        {
          "name": "analyze_strictness",
          "description": "Analyze basic strictness heuristics on a test function.",
          "args": "lines (List[str]): The lines of the test function.\nfunc (Dict[str, Any]): A dictionary containing the test function's metadata.",
          "returns": "Dict[str, Any]: A dictionary containing the analysis results."
        },
        {
          "name": "attach_coverage_hits",
          "description": "Attaches coverage and hit data to each test result and associated production methods.\nNow correctly handles normalized paths and avoids overmatching.",
          "args": null,
          "returns": null
        },
        {
          "name": "compute_strictness_score",
          "description": "Computes a strictness score for each test case based on:\n- Assertion count (asserts)\n- Code coverage (coverage_hit_ratio)\n- Method complexity (from covered methods)\nReturns results with 'strictness_score' and 'strictness_grade'.",
          "args": null,
          "returns": null
        },
        {
          "name": "map_test_to_prod_path",
          "description": "Map a test file path to its corresponding production code path.",
          "args": "test_path (Path): The path to the test file.\ntest_root (Path): The root directory of the test files.\nsource_root (Path): The root directory of the production code.",
          "returns": "Path: The corresponding production code path."
        },
        {
          "name": "map_tests_to_prod_code",
          "description": "Maps test functions to the production code they cover, avoiding overmatching.\nPrioritizes coverage data over directory-based heuristics.",
          "args": null,
          "returns": null
        },
        {
          "name": "scan_test_directory",
          "description": "Scan test directory or single test file and extract test function information.",
          "args": "tests_path (Path): The path to the test directory or test file.",
          "returns": "List[Dict[str, Any]]: A list of dictionaries containing test function information."
        },
        {
          "name": "main",
          "description": null,
          "args": null,
          "returns": null
        }
      ]
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {
        "scan_test_directory": {
          "complexity": 6,
          "coverage": 0.8889,
          "hits": 11,
          "lines": 12,
          "covered_lines": [
            324,
            325,
            327,
            330,
            332,
            333,
            334,
            335,
            336,
            337,
            339
          ],
          "missing_lines": []
        },
        "extract_test_functions": {
          "complexity": 5,
          "coverage": 1.0,
          "hits": 11,
          "lines": 11,
          "covered_lines": [
            59,
            60,
            62,
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70
          ],
          "missing_lines": []
        },
        "analyze_strictness": {
          "complexity": 7,
          "coverage": 1.0,
          "hits": 8,
          "lines": 8,
          "covered_lines": [
            84,
            85,
            87,
            88,
            89,
            90,
            92,
            94
          ],
          "missing_lines": []
        },
        "attach_coverage_hits": {
          "complexity": 11,
          "coverage": 0.8542,
          "hits": 32,
          "lines": 36,
          "covered_lines": [
            112,
            114,
            115,
            116,
            119,
            122,
            123,
            124,
            125,
            127,
            128,
            129,
            130,
            131,
            132,
            134,
            135,
            136,
            143,
            144,
            145,
            147,
            148,
            149,
            150,
            152,
            161,
            162,
            164,
            165,
            166,
            168
          ],
          "missing_lines": []
        },
        "compute_strictness_score": {
          "complexity": 7,
          "coverage": 0.6429,
          "hits": 15,
          "lines": 20,
          "covered_lines": [
            180,
            181,
            182,
            183,
            185,
            186,
            188,
            189,
            190,
            192,
            194,
            197,
            198,
            206,
            208
          ],
          "missing_lines": []
        },
        "map_test_to_prod_path": {
          "complexity": 11,
          "coverage": 0.5806,
          "hits": 13,
          "lines": 21,
          "covered_lines": [
            224,
            226,
            230,
            231,
            232,
            235,
            238,
            239,
            244,
            255,
            256,
            257,
            258
          ],
          "missing_lines": []
        },
        "map_tests_to_prod_code": {
          "complexity": 11,
          "coverage": 0.0,
          "hits": 0,
          "lines": 22,
          "covered_lines": [],
          "missing_lines": []
        },
        "main": {
          "complexity": 15,
          "coverage": 0.5854,
          "hits": 20,
          "lines": 33,
          "covered_lines": [
            344,
            345,
            346,
            348,
            352,
            353,
            355,
            356,
            357,
            364,
            372,
            373,
            374,
            376,
            377,
            379,
            389,
            390,
            391,
            392
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "mypy": {
          "errors": [
            "scripts/refactor/strictness_analyzer.py:260: error: Incompatible return value type (got \"None\", expected \"Path\")  [return-value]",
            "scripts/refactor/strictness_analyzer.py:263: error: Incompatible return value type (got \"None\", expected \"Path\")  [return-value]",
            "scripts/refactor/strictness_analyzer.py:314: error: Name \"scan_test_directory\" already defined on line 35  [no-redef]",
            "scripts/refactor/strictness_analyzer.py:366: error: Argument 1 to \"extract_method_line_ranges\" has incompatible type \"Path\"; expected \"str\"  [arg-type]"
          ]
        },
        "black": {
          "needs_formatting": true
        },
        "pydocstyle": {
          "functions": {
            "scan_test_directory": [
              {
                "code": "D103",
                "message": "Missing docstring in public function"
              }
            ],
            "attach_coverage_hits": [
              {
                "code": "D205",
                "message": "1 blank line required between summary line and description (found 0)"
              }
            ],
            "compute_strictness_score": [
              {
                "code": "D205",
                "message": "1 blank line required between summary line and description (found 0)"
              }
            ],
            "map_tests_to_prod_code": [
              {
                "code": "D205",
                "message": "1 blank line required between summary line and description (found 0)"
              }
            ],
            "main": [
              {
                "code": "D103",
                "message": "Missing docstring in public function"
              }
            ]
          }
        }
      }
    }
  },
  "tests/__init__.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": []
    },
    "coverage": {},
    "linting": {}
  },
  "tests/conftest.py": {
    "docstrings": {
      "module_doc": {
        "description": "conftest.py\nThis module contains configuration and fixtures for pytest testing.\nIt imports and makes available all fixtures from separate modules to keep\nthe testing infrastructure organized and maintainable.",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": []
    },
    "coverage": {},
    "linting": {}
  },
  "tests/fixtures/__init__.py": {
    "docstrings": {
      "module_doc": {
        "description": "Package initialization file for fixtures.\nMakes the fixtures importable when importing from tests.fixtures.",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": []
    },
    "coverage": {},
    "linting": {}
  },
  "tests/fixtures/ai_mock_fixtures.py": {
    "docstrings": {
      "module_doc": {
        "description": "AI and External Service Mocking Fixtures\nThis module provides fixtures for mocking AI components and external services\nused in the application during testing.",
        "args": null,
        "returns": null
      },
      "classes": [
        {
          "name": "FailingSummarizer",
          "description": null,
          "args": null,
          "returns": null
        }
      ],
      "functions": [
        {
          "name": "mock_ollama",
          "description": "Mocks the ollama library functions for testing.",
          "args": null,
          "returns": null
        },
        {
          "name": "mock_sentence_transformer",
          "description": "Provide a fully-mocked SentenceTransformer for *all* tests:\n Registers a fake ``sentence_transformers`` package in ``sys.modules``\n Exposes the same mock on ``scripts.indexers.base_indexer`` so that\nhelpers can patch it with ``patch(\"scripts.indexers.base_indexer.SentenceTransformer\")``.",
          "args": null,
          "returns": null
        },
        {
          "name": "patch_aisummarizer",
          "description": "Patches the AI summarizer for testing.",
          "args": "monkeypatch (Any): The monkeypatch object to use for patching.",
          "returns": null
        },
        {
          "name": "mock_failed_summarizer",
          "description": "Mocks a failed summarizer.",
          "args": null,
          "returns": "Any: The mocked failed summarizer."
        },
        {
          "name": "summarize_entries_bulk",
          "description": null,
          "args": null,
          "returns": null
        }
      ]
    },
    "coverage": {},
    "linting": {}
  },
  "tests/fixtures/core_fixtures.py": {
    "docstrings": {
      "module_doc": {
        "description": "Core Application Fixtures\nThis module provides fixtures for testing core application components like\nthe logger core, summary tracker, and indexers.",
        "args": null,
        "returns": null
      },
      "classes": [
        {
          "name": "DummyEmbeddingModel",
          "description": null,
          "args": null,
          "returns": null
        }
      ],
      "functions": [
        {
          "name": "logger_core",
          "description": "Creates a logger core for testing.",
          "args": "temp_dir (Path): The temporary directory for the logger core.",
          "returns": "Any: The logger core."
        },
        {
          "name": "clean_summary_tracker",
          "description": "Cleans the summary tracker for testing.",
          "args": "logger_core (Any): The logger core to clean.",
          "returns": null
        },
        {
          "name": "reset_config_manager",
          "description": "Resets the configuration manager for testing.",
          "args": null,
          "returns": null
        },
        {
          "name": "stub_indexers",
          "description": "Stubs indexers for testing.",
          "args": "monkeypatch (Any): The monkeypatch object to use for patching.\nmock_raw_log_file (Any): The mocked raw log file.\nmock_correction_summaries_file (Any): The mocked correction summaries file.\ntemp_dir (Path): The temporary directory for the indexers.",
          "returns": null
        },
        {
          "name": "encode",
          "description": null,
          "args": null,
          "returns": null
        },
        {
          "name": "mock_init_summary",
          "description": null,
          "args": null,
          "returns": null
        },
        {
          "name": "mock_init_raw",
          "description": null,
          "args": null,
          "returns": null
        }
      ]
    },
    "coverage": {},
    "linting": {}
  },
  "tests/fixtures/encoding_fixtures.py": {
    "docstrings": {
      "module_doc": {
        "description": "UTF-8 and Locale Management Fixtures\nThis module provides fixtures for ensuring consistent UTF-8 encoding and\nlocale handling during testing, especially in subprocesses.",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "_utf8_subprocess_env",
          "description": "Context-manager that injects UTF-8 friendly env-vars before a subprocess\nstarts and rolls them back afterwards.",
          "args": null,
          "returns": null
        },
        {
          "name": "force_utf8_subprocesses",
          "description": "Session-scoped, autouse  runs once before ANY test executes.\n* sets environment so that every child-process sees UTF-8 encodings\n* patches ``locale.getpreferredencoding`` so libraries that rely on it\n(e.g. `subprocess._readerthread` inside pytest's capture layer) won't\nfall back to CP1252 on Windows.",
          "args": null,
          "returns": null
        }
      ]
    },
    "coverage": {},
    "linting": {}
  },
  "tests/fixtures/safety_fixtures.py": {
    "docstrings": {
      "module_doc": {
        "description": "Test Safety and Integrity Safeguards\nThis module provides fixtures for ensuring test integrity, preventing writes\nto production paths, and maintaining the safety of the test environment.",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "watch_conftest_integrity",
          "description": "Watches the integrity of the conftest.py file.",
          "args": null,
          "returns": null
        },
        {
          "name": "prevent_production_path_writes",
          "description": "Prevents writes to production paths.",
          "args": "monkeypatch (Any): The monkeypatch object to use for patching.",
          "returns": null
        },
        {
          "name": "guarded_open",
          "description": null,
          "args": null,
          "returns": null
        },
        {
          "name": "assert_all_output_in_temp",
          "description": "Asserts all output is in the temporary directory.",
          "args": "tmp_path_factory (Any): The temporary path factory.",
          "returns": null
        }
      ]
    },
    "coverage": {},
    "linting": {}
  },
  "tests/fixtures/temp_dir_fixtures.py": {
    "docstrings": {
      "module_doc": {
        "description": "Temporary Directory and Configuration Management Fixtures\nThis module provides fixtures for creating temporary directories and\nmanaging configuration during testing.",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "temp_dir",
          "description": "Creates a temporary directory for testing.",
          "args": "tmp_path (Path): The temporary path to create the directory.",
          "returns": "Path: The path to the created temporary directory."
        },
        {
          "name": "temp_script_dir",
          "description": "Creates a temporary script directory for testing.",
          "args": "temp_dir (Path): The temporary directory for the script.",
          "returns": "str: The path to the created temporary script directory."
        },
        {
          "name": "temp_config_file",
          "description": "Creates a temporary config file for testing.",
          "args": "temp_dir (Path): The temporary directory for the config file.",
          "returns": "Path: The path to the created temporary config file."
        },
        {
          "name": "patch_config_and_paths",
          "description": "Patches the configuration and paths for testing.",
          "args": "monkeypatch (Any): The monkeypatch object to use for patching.\ntemp_dir (Path): The temporary directory for the configuration.",
          "returns": null
        },
        {
          "name": "build_test_config",
          "description": "Builds a test configuration.",
          "args": "temp_dir (Path): The temporary directory for the configuration.",
          "returns": "dict: The test configuration."
        },
        {
          "name": "safe_path",
          "description": null,
          "args": null,
          "returns": null
        }
      ]
    },
    "coverage": {},
    "linting": {}
  },
  "tests/fixtures/tkinter_fixtures.py": {
    "docstrings": {
      "module_doc": {
        "description": "Tkinter Environment Management Fixtures\nThis module provides fixtures for managing Tkinter in headless environments\nand patching Tkinter components during testing.",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "_force_headless_tk",
          "description": "Ensure Tk works in headless CI.\n If $DISPLAY exists  no-op.\n If not, try xvfb :0; if that fails, monkey-patch tk.Tk with MagicMock.\nReturns True if *real* GUI is available, False if mocked.",
          "args": null,
          "returns": null
        },
        {
          "name": "tk_safe",
          "description": "Yields (root, gui_ok):\nroot   -> a Tk() instance (real or mocked)\ngui_ok -> bool flag (True if real GUI)",
          "args": null,
          "returns": null
        },
        {
          "name": "flush_tk_events",
          "description": null,
          "args": null,
          "returns": null
        },
        {
          "name": "patch_blocking_dialogs",
          "description": null,
          "args": null,
          "returns": null
        }
      ]
    },
    "coverage": {},
    "linting": {}
  },
  "tests/integration/__init__.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": []
    },
    "coverage": {},
    "linting": {}
  },
  "tests/mock_data/__init__.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": []
    },
    "coverage": {},
    "linting": {}
  },
  "tests/mocks/__init__.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": []
    },
    "coverage": {},
    "linting": {}
  },
  "tests/smoke/__init__.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": []
    },
    "coverage": {},
    "linting": {}
  },
  "tests/unit/__init__.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": []
    },
    "coverage": {},
    "linting": {}
  },
  "tests/unit/ai/__init__.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": []
    },
    "coverage": {},
    "linting": {}
  },
  "tests/unit/ci_analyzer/__init__.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": []
    },
    "coverage": {},
    "linting": {}
  },
  "tests/unit/config/__init__.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": []
    },
    "coverage": {},
    "linting": {}
  },
  "tests/unit/core/__init__.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": []
    },
    "coverage": {},
    "linting": {}
  },
  "tests/unit/gui/__init__.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": []
    },
    "coverage": {},
    "linting": {}
  },
  "tests/unit/indexers/__init__.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": []
    },
    "coverage": {},
    "linting": {}
  },
  "tests/unit/kg/__init__.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": []
    },
    "coverage": {},
    "linting": {}
  },
  "tests/unit/kg/modules/__init__.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": []
    },
    "coverage": {},
    "linting": {}
  },
  "tests/unit/refactor/__init__.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": []
    },
    "coverage": {},
    "linting": {}
  },
  "tests/unit/refactor/complexity/__init__.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": []
    },
    "coverage": {},
    "linting": {}
  },
  "tests/unit/refactor/lint_report_pkg/__init__.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": []
    },
    "coverage": {},
    "linting": {}
  },
  "tests/unit/refactor/parsers/__init__.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": []
    },
    "coverage": {},
    "linting": {}
  },
  "tests/unit/utils/__init__.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": []
    },
    "coverage": {},
    "linting": {}
  },
  "utils/__init__.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": []
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {}
    },
    "linting": {
      "quality": {
        "coverage": {
          "percent": 100.0
        }
      }
    }
  },
  "utils/file_io.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "load_json_any",
          "description": "Load .json or compressed .json.{gz,bz2,xz} transparently.\nReturns {} on missing file for caller-side resilience.",
          "args": null,
          "returns": null
        }
      ]
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {
        "load_json_any": {
          "complexity": 3,
          "coverage": 0.0,
          "hits": 0,
          "lines": 7,
          "covered_lines": [],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "mypy": {
          "errors": [
            "scripts/utils/file_io.py:5: error: Bracketed expression \"[...]\" is not valid as a type  [valid-type]",
            "scripts/utils/file_io.py:5: error: Function \"builtins.callable\" is not valid as a type  [valid-type]",
            "scripts/utils/file_io.py:11: error: Missing type parameters for generic type \"PathLike\"  [type-arg]",
            "scripts/utils/file_io.py:22: error: \"callable?[Any, typing.IO[builtins.bytes]]\" not callable  [misc]",
            "scripts/utils/file_io.py:23: error: Returning Any from function declared to return \"dict[str, Any]\"  [no-any-return]"
          ]
        },
        "black": {
          "needs_formatting": true
        },
        "pydocstyle": {
          "functions": {
            "load_json_any": [
              {
                "code": "D205",
                "message": "1 blank line required between summary line and description (found 0)"
              }
            ]
          }
        }
      }
    }
  },
  "utils/file_utils.py": {
    "docstrings": {
      "module_doc": {
        "description": null,
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "sanitize_filename",
          "description": "Return *name* stripped of illegal chars and truncated to 100 chars.",
          "args": null,
          "returns": null
        },
        {
          "name": "get_timestamp",
          "description": "Current time as ``YYYYMMDD_HHMMSS``.",
          "args": null,
          "returns": null
        },
        {
          "name": "_to_path",
          "description": "Internal: coerce *p* to ``Path`` exactly once.",
          "args": null,
          "returns": null
        },
        {
          "name": "safe_path",
          "description": "Ensure ``path.parent`` exists; return ``Path``.",
          "args": null,
          "returns": null
        },
        {
          "name": "write_json",
          "description": null,
          "args": null,
          "returns": null
        },
        {
          "name": "read_json",
          "description": null,
          "args": null,
          "returns": null
        },
        {
          "name": "safe_read_json",
          "description": null,
          "args": null,
          "returns": null
        },
        {
          "name": "make_backup",
          "description": null,
          "args": null,
          "returns": null
        },
        {
          "name": "zip_python_files",
          "description": "Zip all ``.py`` files under *root_dir* (recursively), excluding any directory whose\nname appears in *exclude_dirs* (casesensitive match against each path part).\nIf *exclude_dirs* is ``None`` we default to::{.python}\n{\".venv\", \"__pycache__\", \".git\", \"node_modules\"}",
          "args": "output_path: Destination ``.zip`` path (created/overwritten).\nroot_dir:    Directory to start searching; ``'.'`` by default.\nexclude_dirs: Folder names to skip entirely.",
          "returns": null
        }
      ]
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {
        "sanitize_filename": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 1,
          "lines": 1,
          "covered_lines": [
            40
          ],
          "missing_lines": []
        },
        "get_timestamp": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 1,
          "lines": 1,
          "covered_lines": [
            45
          ],
          "missing_lines": []
        },
        "_to_path": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 1,
          "lines": 1,
          "covered_lines": [
            55
          ],
          "missing_lines": []
        },
        "safe_path": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 3,
          "lines": 3,
          "covered_lines": [
            60,
            61,
            62
          ],
          "missing_lines": []
        },
        "write_json": {
          "complexity": 4,
          "coverage": 1.0,
          "hits": 6,
          "lines": 6,
          "covered_lines": [
            66,
            67,
            68,
            69,
            70,
            71,
            72
          ],
          "missing_lines": []
        },
        "read_json": {
          "complexity": 4,
          "coverage": 1.0,
          "hits": 6,
          "lines": 6,
          "covered_lines": [
            76,
            77,
            78,
            79,
            80,
            81,
            82
          ],
          "missing_lines": []
        },
        "safe_read_json": {
          "complexity": 2,
          "coverage": 0.75,
          "hits": 3,
          "lines": 4,
          "covered_lines": [
            86,
            87,
            90
          ],
          "missing_lines": []
        },
        "make_backup": {
          "complexity": 5,
          "coverage": 0.6923,
          "hits": 8,
          "lines": 11,
          "covered_lines": [
            99,
            100,
            103,
            104,
            105,
            106,
            107,
            108
          ],
          "missing_lines": []
        },
        "zip_python_files": {
          "complexity": 16,
          "coverage": 0.9302,
          "hits": 26,
          "lines": 27,
          "covered_lines": [
            137,
            138,
            141,
            142,
            144,
            145,
            147,
            148,
            149,
            150,
            151,
            152,
            153,
            155,
            157,
            158,
            159,
            161,
            162,
            163,
            164,
            165,
            166,
            168,
            169,
            170
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "flake8": {
          "issues": [
            {
              "line": 8,
              "column": 63,
              "code": "W291",
              "message": "trailing whitespace"
            },
            {
              "line": 8,
              "column": 63,
              "code": "W291",
              "message": "trailing whitespace"
            }
          ]
        },
        "mypy": {
          "errors": [
            "scripts/utils/file_utils.py:65: error: Missing type parameters for generic type \"dict\"  [type-arg]",
            "scripts/utils/file_utils.py:75: error: Missing type parameters for generic type \"dict\"  [type-arg]",
            "scripts/utils/file_utils.py:79: error: Returning Any from function declared to return \"dict[Any, Any]\"  [no-any-return]",
            "scripts/utils/file_utils.py:85: error: Missing type parameters for generic type \"dict\"  [type-arg]",
            "scripts/utils/file_utils.py:169: error: Incompatible types in assignment (expression has type \"str\", variable has type \"Path\")  [assignment]"
          ]
        },
        "pydocstyle": {
          "functions": {
            "write_json": [
              {
                "code": "D103",
                "message": "Missing docstring in public function"
              }
            ],
            "read_json": [
              {
                "code": "D103",
                "message": "Missing docstring in public function"
              }
            ],
            "safe_read_json": [
              {
                "code": "D103",
                "message": "Missing docstring in public function"
              }
            ],
            "make_backup": [
              {
                "code": "D103",
                "message": "Missing docstring in public function"
              }
            ],
            "zip_python_files": [
              {
                "code": "D205",
                "message": "1 blank line required between summary line and description (found 0)"
              }
            ]
          }
        },
        "coverage": {
          "percent": 93.9
        }
      }
    }
  },
  "utils/git_utils.py": {
    "docstrings": {
      "module_doc": {
        "description": "git_utils.py\nThis module provides utility functions for working with Git, including:\n- Getting changed Python files compared to a specified branch.\n- Running an interactive commit flow to create and push a new branch.\nIntended for use in CI workflows and scripts to automate code quality and coverage reporting.",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "get_changed_files",
          "description": "Returns a list of changed Python files compared to the specified Git base branch.\nRuns 'git diff --name-only' to identify changed files and filters for those ending with '.py'.\nHandles compatibility with different Python versions and returns an empty list if the Git command fails.",
          "args": "base (str): The Git base branch or commit to compare against. Defaults to 'origin/main'.",
          "returns": "List[str]: A list of changed Python file paths."
        },
        {
          "name": "interactive_commit_flow",
          "description": "Guides the user through an interactive Git commit and push process.\nPrompts the user to either push changes to the default branch or create and push to a new branch, handling all Git commands interactively.",
          "args": "default_branch (str): The branch to push to by default. Defaults to \"main\".",
          "returns": "None"
        },
        {
          "name": "get_current_branch",
          "description": "Returns the name of the current Git branch as a string.\nExecutes a Git command to determine the active branch in the local repository.",
          "args": null,
          "returns": null
        }
      ]
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {
        "get_changed_files": {
          "complexity": 6,
          "coverage": 0.7,
          "hits": 7,
          "lines": 10,
          "covered_lines": [
            29,
            30,
            32,
            41,
            42,
            44,
            56
          ],
          "missing_lines": []
        },
        "interactive_commit_flow": {
          "complexity": 2,
          "coverage": 1.0,
          "hits": 16,
          "lines": 16,
          "covered_lines": [
            71,
            73,
            74,
            75,
            77,
            81,
            82,
            83,
            84,
            85,
            87,
            88,
            89,
            90,
            91,
            92
          ],
          "missing_lines": []
        },
        "get_current_branch": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 2,
          "lines": 2,
          "covered_lines": [
            101,
            103
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "coverage": {
          "percent": 90.9
        }
      }
    }
  },
  "utils/link_summaries_to_raw_logs.py": {
    "docstrings": {
      "module_doc": {
        "description": "Module for processing raw logs and injecting entries into correction summaries.\nThis module provides functionality to flatten raw log entries based on categories and inject those entries into correction summaries.\nFunctions:\n- flatten_raw_entries: Flattens raw log entries for a specified category and subcategory.\n- inject_entries_into_summaries: Injects raw log entries into correction summaries based on batch labels.",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "flatten_raw_entries",
          "description": "Flatten raw log entries for a given main category and subcategory across all dates,\nsorted chronologically.",
          "args": "raw_logs (dict): Raw logs as loaded from zephyrus_log.json.\nmain_cat (str): The main category.\nsubcat (str): The subcategory.",
          "returns": "list: A list of entries (each is a dict) for the given category/subcategory in chronological order."
        },
        {
          "name": "inject_entries_into_summaries",
          "description": "Injects corresponding raw log entries into each batch of correction summaries based on batch labels.\nLoads configuration to determine file paths, reads raw logs and correction summaries, and for each batch in the summaries,\ninjects the relevant raw entries by extracting their content fields. Updates the summaries file in place.",
          "args": null,
          "returns": "None"
        }
      ]
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {
        "flatten_raw_entries": {
          "complexity": 4,
          "coverage": 0.8571,
          "hits": 8,
          "lines": 8,
          "covered_lines": [
            31,
            33,
            34,
            35,
            36,
            37,
            39,
            40
          ],
          "missing_lines": []
        },
        "inject_entries_into_summaries": {
          "complexity": 14,
          "coverage": 0.8889,
          "hits": 26,
          "lines": 30,
          "covered_lines": [
            53,
            56,
            57,
            62,
            63,
            65,
            66,
            68,
            72,
            73,
            75,
            76,
            80,
            81,
            82,
            85,
            86,
            87,
            88,
            94,
            96,
            99,
            100,
            103,
            104,
            106
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "flake8": {
          "issues": [
            {
              "line": 94,
              "column": 62,
              "code": "E203",
              "message": "whitespace before ':'"
            },
            {
              "line": 94,
              "column": 62,
              "code": "E203",
              "message": "whitespace before ':'"
            }
          ]
        },
        "mypy": {
          "errors": [
            "scripts/utils/link_summaries_to_raw_logs.py:18: error: Missing type parameters for generic type \"dict\"  [type-arg]",
            "scripts/utils/link_summaries_to_raw_logs.py:18: error: Missing type parameters for generic type \"list\"  [type-arg]"
          ]
        },
        "pydocstyle": {
          "functions": {
            "flatten_raw_entries": [
              {
                "code": "D205",
                "message": "1 blank line required between summary line and description (found 0)"
              }
            ]
          }
        },
        "coverage": {
          "percent": 90.9
        }
      }
    }
  },
  "utils/zip_util.py": {
    "docstrings": {
      "module_doc": {
        "description": "zip_util.py\nThis module provides the main entry point for the zip_util utility,\nwhich zips all .py files in a project, excluding specified directories.",
        "args": null,
        "returns": null
      },
      "classes": [],
      "functions": [
        {
          "name": "main",
          "description": "Parses command-line arguments to zip all .py files in a project, excluding specified directories.\nCalls the internal utility to create the zip archive and logs the output path.",
          "args": null,
          "returns": null
        }
      ]
    },
    "coverage": {
      "method_diff": {},
      "missing_tests": [],
      "complexity": {
        "main": {
          "complexity": 1,
          "coverage": 1.0,
          "hits": 6,
          "lines": 6,
          "covered_lines": [
            20,
            23,
            30,
            37,
            45,
            46,
            47
          ],
          "missing_lines": []
        }
      }
    },
    "linting": {
      "quality": {
        "mypy": {
          "errors": [
            "scripts/utils/zip_util.py:15: error: Function is missing a return type annotation  [no-untyped-def]",
            "scripts/utils/zip_util.py:51: error: Call to untyped function \"main\" in typed context  [no-untyped-call]"
          ]
        },
        "pydocstyle": {
          "functions": {
            "main": [
              {
                "code": "D205",
                "message": "1 blank line required between summary line and description (found 0)"
              }
            ]
          }
        }
      }
    }
  }
}